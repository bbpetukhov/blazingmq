<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Class bmqa::AbstractSession</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="bdedox.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bmqa.html" target="_blank">bmqa</a> | <a class="qindex" href="group__bmqpi.html" target="_blank">bmqpi</a> | <a class="qindex" href="group__bmqt.html" target="_blank">bmqt</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="components.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebmqa.html">bmqa</a>      </li>
      <li><a class="el" href="classbmqa_1_1AbstractSession.html">bmqa::AbstractSession</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bmqa::AbstractSession Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bmqa::AbstractSession" -->
<p><code>#include &lt;<a class="el" href="bmqa__abstractsession_8h_source.html">bmqa_abstractsession.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for bmqa::AbstractSession:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbmqa_1_1AbstractSession.png" usemap="#bmqa::AbstractSession_map" alt=""/>
  <map id="bmqa::AbstractSession_map" name="bmqa::AbstractSession_map">
<area href="classbmqa_1_1MockSession.html" alt="bmqa::MockSession" shape="rect" coords="0,56,138,80"/>
<area href="classbmqa_1_1Session.html" alt="bmqa::Session" shape="rect" coords="148,56,286,80"/>
</map>
</div>

<p><a href="classbmqa_1_1AbstractSession-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void(const <br class="typebreak"/>
<a class="el" href="classbmqa_1_1OpenQueueStatus.html">bmqa::OpenQueueStatus</a> &amp;result)&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a75e7237336027136889801133334b72d">OpenQueueCallback</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void(const <br class="typebreak"/>
<a class="el" href="classbmqa_1_1ConfigureQueueStatus.html">bmqa::ConfigureQueueStatus</a> <br class="typebreak"/>
&amp;result)&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a0a63dcba9d8cabae9bb083865db83c20">ConfigureQueueCallback</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void(const <br class="typebreak"/>
<a class="el" href="classbmqa_1_1CloseQueueStatus.html">bmqa::CloseQueueStatus</a> &amp;result)&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a657f8f6d3779ef7b5697be304e8415c6">CloseQueueCallback</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#acd6114e109853a8b16694dfa60db6ef9">~AbstractSession</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a88337ae19f335352f32f98818d2d82e9">start</a> (const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a42ba613e230863b89cd8f31413b9afc0">startAsync</a> (const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a39b54dd9aff5fb0165dfb382641f7606">stop</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a6431f6eee936f03b40fa33385832824a">stopAsync</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a5a790a8e3881e37740023204ea5f71fa">finalizeStop</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#acee2b8777224bfb88f59904551c69755">loadMessageEventBuilder</a> (<a class="el" href="classbmqa_1_1MessageEventBuilder.html">MessageEventBuilder</a> *builder)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a0662d3695901ef024ea773abf8a50482">loadConfirmEventBuilder</a> (<a class="el" href="classbmqa_1_1ConfirmEventBuilder.html">ConfirmEventBuilder</a> *builder)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#ab5b6459aa7eb97c5a058ef9a8f1f6409">loadMessageProperties</a> (<a class="el" href="classbmqa_1_1MessageProperties.html">MessageProperties</a> *buffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a897bf80e972bd2d8d356c89ac7960431">getQueueId</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;uri) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#af07daee8b4e090189aa719c896e1e14f">getQueueId</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1CorrelationId.html">bmqt::CorrelationId</a> &amp;correlationId) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a24e5640b6226a6ff8d43a0d4015f0b16">openQueue</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;uri, bsls::Types::Uint64 flags, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options=<a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbmqa_1_1OpenQueueStatus.html">OpenQueueStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a7facfe47066415f6977ef6b78547ca43">openQueueSync</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;uri, bsls::Types::Uint64 flags, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options=<a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a9c526171c5bf03bd1b3ea993bdc7fabc">openQueueAsync</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;uri, bsls::Types::Uint64 flags, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options=<a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a44c23507ec0aaf46d526d02dee341e09">openQueueAsync</a> (<a class="el" href="classbmqa_1_1QueueId.html">bmqa::QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;uri, bsls::Types::Uint64 flags, const <a class="el" href="classbmqa_1_1AbstractSession.html#a75e7237336027136889801133334b72d">OpenQueueCallback</a> &amp;callback, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options=<a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#af118dfa2165a17cc22786f84b080fa96">configureQueue</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbmqa_1_1ConfigureQueueStatus.html">ConfigureQueueStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a7d090b4869286909fbc78c7da2214e7f">configureQueueSync</a> (const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a77fd57363c294a6c390503e31f54ec38">configureQueueAsync</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a183bd13f3f968d2524c3a890127f2fad">configureQueueAsync</a> (const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options, const <a class="el" href="classbmqa_1_1AbstractSession.html#a0a63dcba9d8cabae9bb083865db83c20">ConfigureQueueCallback</a> &amp;callback, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a773a86f6ff75cc4dd328ddedd2d7e886">closeQueue</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbmqa_1_1CloseQueueStatus.html">CloseQueueStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a1c8ece4df2266e698dd51af3101abc54">closeQueueSync</a> (const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a8b4b33f933be8f5be5b17f508c83c13f">closeQueueAsync</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a4766c5a33a2714c53ebb147e6298b2f1">closeQueueAsync</a> (const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqa_1_1AbstractSession.html#a657f8f6d3779ef7b5697be304e8415c6">CloseQueueCallback</a> &amp;callback, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbmqa_1_1Event.html">Event</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#ab791e98ffb989c97411966856a4d527b">nextEvent</a> (const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a5b338c949ef2d008e2e491bcc74f9ecd">post</a> (const <a class="el" href="classbmqa_1_1MessageEvent.html">MessageEvent</a> &amp;event)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#ac0fbce3bb5f93d991063bea9ea3ebb8d">confirmMessage</a> (const <a class="el" href="classbmqa_1_1Message.html">Message</a> &amp;message)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#af78c7080723764b041baf5825fab4ed7">confirmMessage</a> (const <a class="el" href="classbmqa_1_1MessageConfirmationCookie.html">MessageConfirmationCookie</a> &amp;cookie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a8487ac7a95e51c25c6bbacf822786972">confirmMessages</a> (<a class="el" href="classbmqa_1_1ConfirmEventBuilder.html">ConfirmEventBuilder</a> *builder)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a777888d11903cac52eb14915ad29e4be">configureMessageDumping</a> (const bslstl::StringRef &amp;command)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A pure protocol for a session.</p>
<p>See <a class="el" href="group__bmqa__abstractsession.html">Component bmqa_abstractsession</a> </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a75e7237336027136889801133334b72d"></a><!-- doxytag: member="bmqa::AbstractSession::OpenQueueCallback" ref="a75e7237336027136889801133334b72d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void(const <a class="el" href="classbmqa_1_1OpenQueueStatus.html">bmqa::OpenQueueStatus</a>&amp; result)&gt; <a class="el" href="classbmqa_1_1AbstractSession.html#a75e7237336027136889801133334b72d">bmqa::AbstractSession::OpenQueueCallback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoked as a response to an asynchronous open queue operation, <code>OpenQueueCallback</code> is an alias for a callback function object (functor) that takes as an argument the specified <code>result</code>, providing the result and context of the requested operation. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1Session.html#a4287dbcc814771d709b3d48094641519">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a0a63dcba9d8cabae9bb083865db83c20"></a><!-- doxytag: member="bmqa::AbstractSession::ConfigureQueueCallback" ref="a0a63dcba9d8cabae9bb083865db83c20" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void(const <a class="el" href="classbmqa_1_1ConfigureQueueStatus.html">bmqa::ConfigureQueueStatus</a>&amp; result)&gt; <a class="el" href="classbmqa_1_1AbstractSession.html#a0a63dcba9d8cabae9bb083865db83c20">bmqa::AbstractSession::ConfigureQueueCallback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoked as a response to an asynchronous configure queue operation, <code>ConfigureQueueCallback</code> is an alias for a callback function object (functor) that takes as an argument the specified <code>result</code>, providing the result and context of the requested operation. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1Session.html#aade4d05e446e2bc2a93f5821d8d508e7">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a657f8f6d3779ef7b5697be304e8415c6"></a><!-- doxytag: member="bmqa::AbstractSession::CloseQueueCallback" ref="a657f8f6d3779ef7b5697be304e8415c6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void(const <a class="el" href="classbmqa_1_1CloseQueueStatus.html">bmqa::CloseQueueStatus</a>&amp; result)&gt; <a class="el" href="classbmqa_1_1AbstractSession.html#a657f8f6d3779ef7b5697be304e8415c6">bmqa::AbstractSession::CloseQueueCallback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoked as a response to an asynchronous close queue operation, <code>CloseQueueCallback</code> is an alias for a callback function object (functor) that takes as an argument the specified <code>result</code>, providing the result and context of the requested operation. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1Session.html#af8b2998c51e4a9f8d83ecf9a9751a8e7">bmqa::Session</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acd6114e109853a8b16694dfa60db6ef9"></a><!-- doxytag: member="bmqa::AbstractSession::~AbstractSession" ref="acd6114e109853a8b16694dfa60db6ef9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bmqa::AbstractSession::~AbstractSession </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a88337ae19f335352f32f98818d2d82e9"></a><!-- doxytag: member="bmqa::AbstractSession::start" ref="a88337ae19f335352f32f98818d2d82e9" args="(const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int bmqa::AbstractSession::start </td>
          <td>(</td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connect to the BlazingMQ broker and start the message processing for this <code><a class="el" href="classbmqa_1_1Session.html">Session</a></code>. This method blocks until either the <code><a class="el" href="classbmqa_1_1Session.html">Session</a></code> is connected to the broker, fails to connect, or the operation times out. If the optionally specified <code>timeout</code> is not populated, use the one defined in the session options. Return 0 on success, or a non-zero value corresponding to the <code><a class="el" href="structbmqt_1_1GenericResult.html#a637624d4e7f6e21b9411b630769286cc">bmqt::GenericResult::Enum</a></code> enum values otherwise. The behavior is undefined if this method is called on an already started <code><a class="el" href="classbmqa_1_1Session.html">Session</a></code>. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#a3ccee44dfcfd49715bd0117789a18800">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#a5f8aafcc526a95123bab44f321ee23b6">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a42ba613e230863b89cd8f31413b9afc0"></a><!-- doxytag: member="bmqa::AbstractSession::startAsync" ref="a42ba613e230863b89cd8f31413b9afc0" args="(const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int bmqa::AbstractSession::startAsync </td>
          <td>(</td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connect to the BlazingMQ broker and start the message processing for this <code><a class="el" href="classbmqa_1_1Session.html">Session</a></code>. This method returns without blocking. The result of the operation is communicated with a session event. If the optionally specified <code>timeout</code> is not populated, use the one defined in the session options. Return 0 on success (this doesn't imply the session is connected !), or a non-zero value corresponding to the <code><a class="el" href="structbmqt_1_1GenericResult.html#a637624d4e7f6e21b9411b630769286cc">bmqt::GenericResult::Enum</a></code> enum values otherwise. The behavior is undefined if this method is called on an already started <code><a class="el" href="classbmqa_1_1Session.html">Session</a></code>. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#a82c46ae947da30980239a2f74f20ecc9">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#a8f0d219488c2334aee8173f5239ff9c6">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a39b54dd9aff5fb0165dfb382641f7606"></a><!-- doxytag: member="bmqa::AbstractSession::stop" ref="a39b54dd9aff5fb0165dfb382641f7606" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bmqa::AbstractSession::stop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gracefully disconnect from the BlazingMQ broker and stop the operation of this <code><a class="el" href="classbmqa_1_1Session.html">Session</a></code>. This method blocks waiting for all already invoked event handlers to exit and all session-related operations to be finished. No other method but <code><a class="el" href="classbmqa_1_1AbstractSession.html#a88337ae19f335352f32f98818d2d82e9">start()</a></code> may be used after this method returns. This method must <em>NOT</em> be called if the session is in synchronous mode (i.e., not using the EventHandler), <code><a class="el" href="classbmqa_1_1AbstractSession.html#a6431f6eee936f03b40fa33385832824a">stopAsync()</a></code> should be called in this case. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#a8dc6733c0ebe7d7595d743ad2f3bb722">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#a8ce13e884cd76e2f60738d8fc0c68722">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a6431f6eee936f03b40fa33385832824a"></a><!-- doxytag: member="bmqa::AbstractSession::stopAsync" ref="a6431f6eee936f03b40fa33385832824a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bmqa::AbstractSession::stopAsync </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disconnect from the BlazingMQ broker and stop the operation of this <code><a class="el" href="classbmqa_1_1Session.html">Session</a></code>. This method returns without blocking and neither enforce nor waits for any already started session-related operation to be finished. No method may be used after this method returns. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#ae29ebfed50a62dc98c05145cc1734e97">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#a8cb915eee3acc7668db74d2c31e96f6c">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a5a790a8e3881e37740023204ea5f71fa"></a><!-- doxytag: member="bmqa::AbstractSession::finalizeStop" ref="a5a790a8e3881e37740023204ea5f71fa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bmqa::AbstractSession::finalizeStop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>**DEPRECATED**</p>
<p>This method is only to be used if the session is in synchronous mode (i.e., not using the EventHandler): it must be called once all threads getting events with <code><a class="el" href="classbmqa_1_1AbstractSession.html#ab791e98ffb989c97411966856a4d527b">nextEvent()</a></code> have been joined. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#a79319928a7edcc5f20c31458b8cf2611">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#ae3f12b32febe243a70a74378c22037df">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="acee2b8777224bfb88f59904551c69755"></a><!-- doxytag: member="bmqa::AbstractSession::loadMessageEventBuilder" ref="acee2b8777224bfb88f59904551c69755" args="(MessageEventBuilder *builder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bmqa::AbstractSession::loadMessageEventBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1MessageEventBuilder.html">MessageEventBuilder</a> *&nbsp;</td>
          <td class="paramname"> <em>builder</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>builder</code> an instance of <code><a class="el" href="classbmqa_1_1MessageEventBuilder.html">bmqa::MessageEventBuilder</a></code> that can be used to build message event for posting on this session. The behavior is undefined unless the session has been successfully started and <code>builder</code> is non-null. Note that lifetime of the loaded object is bound by the lifetime of this session instance (i.e., loaded instance cannot outlive this session instance). Also note that the <code><a class="el" href="classbmqa_1_1MessageEventBuilder.html">MessageEventBuilder</a></code> objects are pooled, so this operation is cheap, and <code><a class="el" href="classbmqa_1_1MessageEventBuilder.html">MessageEventBuilder</a></code> can be obtained on demand and kept on the stack. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#a9633da94c262bb82ff74133532c1e07a">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#a898eeb0dd7a3407bb1a2788ae8ecb7ff">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a0662d3695901ef024ea773abf8a50482"></a><!-- doxytag: member="bmqa::AbstractSession::loadConfirmEventBuilder" ref="a0662d3695901ef024ea773abf8a50482" args="(ConfirmEventBuilder *builder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bmqa::AbstractSession::loadConfirmEventBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1ConfirmEventBuilder.html">ConfirmEventBuilder</a> *&nbsp;</td>
          <td class="paramname"> <em>builder</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>builder</code> an instance of <code><a class="el" href="classbmqa_1_1ConfirmEventBuilder.html">bmqa::ConfirmEventBuilder</a></code> that can be used to build a batch of CONFIRM messages for sending to the broker. The behavior is undefined unless the session has been successfully started and <code>builder</code> is non-null. Note that the lifetime of the loaded object is bound by the lifetime of this session instance (i.e., loaded instance cannot outlive this session instance). </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#ae7cc10715077b9f3cd2d4d577b77352b">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#ae1308efd8c03f795c33bd4c8a48790c4">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="ab5b6459aa7eb97c5a058ef9a8f1f6409"></a><!-- doxytag: member="bmqa::AbstractSession::loadMessageProperties" ref="ab5b6459aa7eb97c5a058ef9a8f1f6409" args="(MessageProperties *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bmqa::AbstractSession::loadMessageProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1MessageProperties.html">MessageProperties</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>buffer</code> an instance of <code><a class="el" href="classbmqa_1_1MessageProperties.html">MessageProperties</a></code> that can be used to specify and associate properties while building a <code><a class="el" href="classbmqa_1_1Message.html">bmqa::Message</a></code>. The behavior is undefined unless the session has been successfully started and <code>buffer</code> is non-null. Note that lifetime of the loaded object is bound by the lifetime of this session instance (i.e., loaded instance cannot outlive this session instance). </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#ae21e898c9d668653f7ac9960722aa348">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#af92a8ab7524dc908ece5da97744a22f3">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a897bf80e972bd2d8d356c89ac7960431"></a><!-- doxytag: member="bmqa::AbstractSession::getQueueId" ref="a897bf80e972bd2d8d356c89ac7960431" args="(QueueId *queueId, const bmqt::Uri &amp;uri) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int bmqa::AbstractSession::getQueueId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uri</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load in the specified <code>queueId</code> the queue corresponding to the specified <code>uri</code> and return 0 if such a queue was found, or leave <code>queueId</code> untouched and return a non-zero value if no queue corresponding to <code>uri</code> is currently open. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#ad57bb8b0fc70a5fee325dd855760c478">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#ab175af39f8ffedcc7f22ab5d68663c4a">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="af07daee8b4e090189aa719c896e1e14f"></a><!-- doxytag: member="bmqa::AbstractSession::getQueueId" ref="af07daee8b4e090189aa719c896e1e14f" args="(QueueId *queueId, const bmqt::CorrelationId &amp;correlationId) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int bmqa::AbstractSession::getQueueId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1CorrelationId.html">bmqt::CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load in the specified <code>queueId</code> the queue corresponding to the specified <code>correlationId</code> and return 0 if such a queue was found, or leave <code>queueId</code> untouched and return a non-zero value if no queue corresponding to <code>correlationId</code> is currently open. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#a47da4b4df84373fde60e733e032f995b">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#a81ba9d0450e48ef9a69914ab0398eb30">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a24e5640b6226a6ff8d43a0d4015f0b16"></a><!-- doxytag: member="bmqa::AbstractSession::openQueue" ref="a24e5640b6226a6ff8d43a0d4015f0b16" args="(QueueId *queueId, const bmqt::Uri &amp;uri, bsls::Types::Uint64 flags, const bmqt::QueueOptions &amp;options=bmqt::QueueOptions(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int bmqa::AbstractSession::openQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsls::Types::Uint64&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DEPRECATED: Use the <code>openQueueSync(<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId...)</code> instead. This method will be marked as <code>BSLS_ANNOTATION_DEPRECATED</code> in future release of libbmq. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#aa8af7af8371bc818ef162e4cd03c4909">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#a25059f75562d96250889ea230cae2bfd">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a7facfe47066415f6977ef6b78547ca43"></a><!-- doxytag: member="bmqa::AbstractSession::openQueueSync" ref="a7facfe47066415f6977ef6b78547ca43" args="(QueueId *queueId, const bmqt::Uri &amp;uri, bsls::Types::Uint64 flags, const bmqt::QueueOptions &amp;options=bmqt::QueueOptions(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbmqa_1_1OpenQueueStatus.html">OpenQueueStatus</a> bmqa::AbstractSession::openQueueSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsls::Types::Uint64&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Open the queue having the specified <code>uri</code> with the specified <code>flags</code> (a combination of the values defined in <code><a class="el" href="structbmqt_1_1QueueFlags.html#a7f1a1e2ba9084565388e19bc1921a4f2">bmqt::QueueFlags::Enum</a></code>), using the specified <code>queueId</code> to correlate events related to that queue. The object <code>queueId</code> referring to is modified, so the <code>queueId</code> represents the actual queue uri, flags and options. Return a result providing the status and context of the operation. Use the optionally specified <code>options</code> to configure some advanced settings. Note that this operation fails if <code>queueId</code> is non-unique. If the optionally specified <code>timeout</code> is not populated, use the one defined in the session options. This operation will block until either success, failure, or timing out happens.</p>
<p>THREAD: Note that calling this method from the event processing thread(s) (i.e., from the EventHandler callback, if provided) <em>WILL</em> lead to a <em>DEADLOCK</em>. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#abfd516749dbd4c8e412b23ce4f851d35">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#a7b62b74a9a4d4dd3e24765d6e54e8c9a">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a9c526171c5bf03bd1b3ea993bdc7fabc"></a><!-- doxytag: member="bmqa::AbstractSession::openQueueAsync" ref="a9c526171c5bf03bd1b3ea993bdc7fabc" args="(QueueId *queueId, const bmqt::Uri &amp;uri, bsls::Types::Uint64 flags, const bmqt::QueueOptions &amp;options=bmqt::QueueOptions(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int bmqa::AbstractSession::openQueueAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsls::Types::Uint64&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DEPRECATED: Use the <code>openQueueAsync(...)</code> with callback flavor instead. This method will be marked as <code>BSLS_ANNOTATION_DEPRECATED</code> in future release of libbmq. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#a4fa5863373125d2cdca72dcf7e5a3ae4">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#a97d407ebfe405a0baa9a8e3a14d98759">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a44c23507ec0aaf46d526d02dee341e09"></a><!-- doxytag: member="bmqa::AbstractSession::openQueueAsync" ref="a44c23507ec0aaf46d526d02dee341e09" args="(bmqa::QueueId *queueId, const bmqt::Uri &amp;uri, bsls::Types::Uint64 flags, const OpenQueueCallback &amp;callback, const bmqt::QueueOptions &amp;options=bmqt::QueueOptions(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bmqa::AbstractSession::openQueueAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">bmqa::QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsls::Types::Uint64&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1AbstractSession.html#a75e7237336027136889801133334b72d">OpenQueueCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously open the queue having the specified <code>uri</code> with the specified <code>flags</code> (a combination of the values defined in <code><a class="el" href="structbmqt_1_1QueueFlags.html#a7f1a1e2ba9084565388e19bc1921a4f2">bmqt::QueueFlags::Enum</a></code>), using the specified <code>queueId</code> to correlate events related to that queue and the optionally specified <code>options</code> to configure some advanced settings. The object <code>queueId</code> referring to is modified, so the <code>queueId</code> represents the actual queue uri, flags and options. The result of the operation is communicated to the specified <code>callback</code> via a <code><a class="el" href="classbmqa_1_1OpenQueueStatus.html">bmqa::OpenQueueStatus</a></code>, providing the status and context of the requested operation. Note that this operation fails if <code>queueId</code> is non-unique. If the optionally specified <code>timeout</code> is not populated, use the one defined in the session options.</p>
<p>THREAD: The <code>callback</code> will <em>ALWAYS</em> be invoked from the EventHandler thread(s) (or if a <a class="el" href="classbmqa_1_1SessionEventHandler.html">SessionEventHandler</a> was not specified, from the thread invoking <code>nextEvent</code>). </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#a134cbd47f159b10b65040ae4dd076db4">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#a2b1d044be01c38d033047e829763fb0f">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="af118dfa2165a17cc22786f84b080fa96"></a><!-- doxytag: member="bmqa::AbstractSession::configureQueue" ref="af118dfa2165a17cc22786f84b080fa96" args="(QueueId *queueId, const bmqt::QueueOptions &amp;options, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int bmqa::AbstractSession::configureQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DEPRECATED: Use the 'configureQueueSync(<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId...) instead. This method will be marked as <code>BSLS_ANNOTATION_DEPRECATED</code> in future release of libbmq. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#a68b18cc9c0eff992a3536c4988c96251">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#a537def25e7ee779b63a4fca8bfcefbcc">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a7d090b4869286909fbc78c7da2214e7f"></a><!-- doxytag: member="bmqa::AbstractSession::configureQueueSync" ref="a7d090b4869286909fbc78c7da2214e7f" args="(const QueueId *queueId, const bmqt::QueueOptions &amp;options, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbmqa_1_1ConfigureQueueStatus.html">ConfigureQueueStatus</a> bmqa::AbstractSession::configureQueueSync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configure the queue identified by the specified <code>queueId</code> using the specified <code>options</code> and return a result providing the status and context of the operation. Fields from <code>options</code> that have not been explicitly set will not be modified. If the optionally specified <code>timeout</code> is not populated, use the one defined in the session options. This operation returns error if there is a pending configure for the same queue. This operation will block until either success, failure, or timing out happens.</p>
<p>THREAD: Note that calling this method from the event processing thread(s) (i.e., from the EventHandler callback, if provided) <em>WILL</em> lead to a <em>DEADLOCK</em>. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#a4986cbd66587a026565c8663efd62bb2">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#af10950d3245e8acf6a4fc4403c7f433a">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a77fd57363c294a6c390503e31f54ec38"></a><!-- doxytag: member="bmqa::AbstractSession::configureQueueAsync" ref="a77fd57363c294a6c390503e31f54ec38" args="(QueueId *queueId, const bmqt::QueueOptions &amp;options, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int bmqa::AbstractSession::configureQueueAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DEPRECATED: Use the <code>configureQueueAsync(...)</code> with callback flavor instead. This method will be marked as <code>BSLS_ANNOTATION_DEPRECATED</code> in future release of libbmq. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#ae352999956a9a8a68179a714fe0c3306">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#a713131557d6b53c042b0fa798eb5991e">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a183bd13f3f968d2524c3a890127f2fad"></a><!-- doxytag: member="bmqa::AbstractSession::configureQueueAsync" ref="a183bd13f3f968d2524c3a890127f2fad" args="(const QueueId *queueId, const bmqt::QueueOptions &amp;options, const ConfigureQueueCallback &amp;callback, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bmqa::AbstractSession::configureQueueAsync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1AbstractSession.html#a0a63dcba9d8cabae9bb083865db83c20">ConfigureQueueCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#a3845bef0c8ca02fd737fe975815f354f">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#acef278ef21a184e84fc0f40fc48630db">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a773a86f6ff75cc4dd328ddedd2d7e886"></a><!-- doxytag: member="bmqa::AbstractSession::closeQueue" ref="a773a86f6ff75cc4dd328ddedd2d7e886" args="(QueueId *queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int bmqa::AbstractSession::closeQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DEPRECATED: Use the 'closeQueueSync(<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId...) instead. This method will be marked as <code>BSLS_ANNOTATION_DEPRECATED</code> in future release of libbmq. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#a8cecfb0853dd4fe41e246fb9905cc95e">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#a109e6bef1a92915e7a9787c1ca719f5e">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a1c8ece4df2266e698dd51af3101abc54"></a><!-- doxytag: member="bmqa::AbstractSession::closeQueueSync" ref="a1c8ece4df2266e698dd51af3101abc54" args="(const QueueId *queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbmqa_1_1CloseQueueStatus.html">CloseQueueStatus</a> bmqa::AbstractSession::closeQueueSync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close the queue identified by the specified <code>queueId</code> and return a result providing the status and context of the operation. If the optionally specified <code>timeout</code> is not populated, use the one defined in the session options. Any outstanding configureQueue request for this <code>queueId</code> will be canceled. This operation will block until either success, failure, or timing out happens. Once this method returns, there is guarantee that no more messages and events for this <code>queueId</code> will be received. Note that successful processing of this request in the broker closes this session's view of the queue; the underlying queue may not be deleted in the broker. When this method returns, the correlationId associated to the queue is cleared.</p>
<p>THREAD: Note that calling this method from the event processing thread(s) (i.e., from the EventHandler callback, if provided) <em>WILL</em> lead to a <em>DEADLOCK</em>. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#a1a016fc12d2039ca3efdf01b287714dc">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#aa02a0adb8aa506268903a6e9b14ee11a">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a8b4b33f933be8f5be5b17f508c83c13f"></a><!-- doxytag: member="bmqa::AbstractSession::closeQueueAsync" ref="a8b4b33f933be8f5be5b17f508c83c13f" args="(QueueId *queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int bmqa::AbstractSession::closeQueueAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DEPRECATED: Use the <code>closeQueueAsync(...)</code> with callback flavor instead. This method will be marked as <code>BSLS_ANNOTATION_DEPRECATED</code> in future release of libbmq. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#ac1b6fe877b8711b489428613a55d7d2c">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#ad1ff2484bb7e6a9edb7d4d8e72dee8f4">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a4766c5a33a2714c53ebb147e6298b2f1"></a><!-- doxytag: member="bmqa::AbstractSession::closeQueueAsync" ref="a4766c5a33a2714c53ebb147e6298b2f1" args="(const QueueId *queueId, const CloseQueueCallback &amp;callback, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bmqa::AbstractSession::closeQueueAsync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1AbstractSession.html#a657f8f6d3779ef7b5697be304e8415c6">CloseQueueCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously close the queue identified by the specified <code>queueId</code>. Any outstanding configureQueue requests will be canceled. The result of the operation is communicated to the specified <code>callback</code> via a <code><a class="el" href="classbmqa_1_1CloseQueueStatus.html">bmqa::CloseQueueStatus</a></code>, providing the status and context of the operation. If the optionally specified <code>timeout</code> is not populated, use the one defined in the session options. Note that successful processing of this request in the broker closes this session's view of the queue; the underlying queue may not be deleted in the broker. The correlationId associated to the queue remains valid until the <code><a class="el" href="classbmqa_1_1CloseQueueStatus.html">bmqa::CloseQueueStatus</a></code> result has been received and processed by the <code>callback</code>, after which it will be cleared and no more messages and events for this <code>queueId</code> will be received.</p>
<p>THREAD: The <code>callback</code> will <em>ALWAYS</em> be invoked from the EventHandler thread(s) (or if a <a class="el" href="classbmqa_1_1SessionEventHandler.html">SessionEventHandler</a> was not specified, from the thread invoking <code>nextEvent</code>). </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#acf330edf0bab3cae2b13da59736fd8ef">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#a61942408f7dddfa79a8efb7cf8f0bfe8">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="ab791e98ffb989c97411966856a4d527b"></a><!-- doxytag: member="bmqa::AbstractSession::nextEvent" ref="ab791e98ffb989c97411966856a4d527b" args="(const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbmqa_1_1Event.html">Event</a> bmqa::AbstractSession::nextEvent </td>
          <td>(</td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the next available event received for this session. If there is no event available, this method blocks for up to the optionally specified <code>timeout</code> time interval for an event to arrive. An empty time interval for <code>timeout</code> (the default) indicates that the method should not timeout (the method will not return until the next event is available). Return a <code><a class="el" href="classbmqa_1_1SessionEvent.html">bmqa::SessionEvent</a></code> of type <code><a class="el" href="structbmqt_1_1SessionEventType.html#aef449af38af76209352bf82f78b92529a1a1a1dc0cc1210cfef1574a0afe59339" title="Time out of the operation.">bmqt::SessionEventType::e_TIMEOUT</a></code> if a timeout was specified and that timeout expired before any event was received. Note that this method can only be used if the session is in synchronous mode (ie not using the EventHandler). The behavior is undefined unless the session was started. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#aabdfafe3f69ab8ae30559f9b39336376">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#a865d173f667d4901324c2ef58e1ec8ba">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a5b338c949ef2d008e2e491bcc74f9ecd"></a><!-- doxytag: member="bmqa::AbstractSession::post" ref="a5b338c949ef2d008e2e491bcc74f9ecd" args="(const MessageEvent &amp;event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int bmqa::AbstractSession::post </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1MessageEvent.html">MessageEvent</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously post the specified <code>event</code> that must contain one or more <code>Messages</code>. The return value is one of the values defined in the <code><a class="el" href="structbmqt_1_1PostResult.html#a61bdfd3cd65c26eaccf02390c514cd76" title="GENERIC.">bmqt::PostResult::Enum</a></code> enum. Return zero on success and a non-zero value otherwise. Note that success implies that SDK has accepted the <code>event</code> and will eventually deliver it to the broker. The behavior is undefined unless the session was started. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#aa9b85b4355f83b4f33e7381f131c5ab4">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#a6e1d0349415ed25dafc141ad6d68c7e7">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="ac0fbce3bb5f93d991063bea9ea3ebb8d"></a><!-- doxytag: member="bmqa::AbstractSession::confirmMessage" ref="ac0fbce3bb5f93d991063bea9ea3ebb8d" args="(const Message &amp;message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int bmqa::AbstractSession::confirmMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1Message.html">Message</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>message</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously confirm the receipt of the specified <code>message</code>. This indicates that the application is done processing the message and that the broker can safely discard it from the queue according to the retention policy set up for that queue. Return 0 on success, and a non-zero value otherwise. Note that success implies that SDK has accepted the <code>message</code> and will eventually send confirmation notification to the broker. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#aa0e92d35e2a134a88144aadef4a390b8">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#a0b977f8da81201169727727c8bc86c7c">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="af78c7080723764b041baf5825fab4ed7"></a><!-- doxytag: member="bmqa::AbstractSession::confirmMessage" ref="af78c7080723764b041baf5825fab4ed7" args="(const MessageConfirmationCookie &amp;cookie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int bmqa::AbstractSession::confirmMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1MessageConfirmationCookie.html">MessageConfirmationCookie</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cookie</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously confirm the receipt of the message with which the specified <code>cookie</code> is associated. This indicates that the application is done processing the message and that the broker can safely discard it from the queue according to the retention policy set up for that queue. Return 0 on success, and a non-zero value otherwise. Note that success implies that SDK has accepted the <code>message</code> and will eventually send confirmation notification to the broker. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#a0b29178d3c4b2c125289d498d242be11">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#a165f5b7d76359fb497e57577fe672cec">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a8487ac7a95e51c25c6bbacf822786972"></a><!-- doxytag: member="bmqa::AbstractSession::confirmMessages" ref="a8487ac7a95e51c25c6bbacf822786972" args="(ConfirmEventBuilder *builder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int bmqa::AbstractSession::confirmMessages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1ConfirmEventBuilder.html">ConfirmEventBuilder</a> *&nbsp;</td>
          <td class="paramname"> <em>builder</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously confirm the receipt of the batch of CONFIRM messages contained in the specified <code>builder</code>. This indicates that the application is done processing all of the messages and that the broker can safely discard them from the queue according to the retention policy set up for that queue. Return 0 on success, and a non-zero value otherwise. Note that in case of success, the instance pointed by the <code>builder</code> will be reset. Also note that success implies that SDK has accepted all of the messages in <code>builder</code> and will eventually send confirmation notification to the broker. Behavior is undefined unless <code>builder</code> is non-null. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#a38634ff51f7ef256616b581086ff657f">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#ad956f64b183e04e20c23ad7b8846eb28">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a777888d11903cac52eb14915ad29e4be"></a><!-- doxytag: member="bmqa::AbstractSession::configureMessageDumping" ref="a777888d11903cac52eb14915ad29e4be" args="(const bslstl::StringRef &amp;command)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int bmqa::AbstractSession::configureMessageDumping </td>
          <td>(</td>
          <td class="paramtype">const bslstl::StringRef &amp;&nbsp;</td>
          <td class="paramname"> <em>command</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configure this session instance to dump messages to the installed logger at <code>ball::Severity::INFO</code> level according to the specified <code>command</code> that should adhere to the following pattern: </p>
<div class="fragment"><pre class="fragment">           IN|OUT ON|OFF|100|10s
</pre></div><p> where each token has a specific meaning: </p>
<ul>
<li>
<b>IN</b> : incoming (<code>PUSH</code> and <code>ACK</code>) events  </li>
<li>
<b>OUT</b> : outgoing (<code>PUT</code> and <code>CONFIRM</code>) events  </li>
<li>
<b>ON</b> : turn on message dumping until explicitly turned off  </li>
<li>
<b>OFF</b> : turn off message dumping  </li>
<li>
<b>100</b> : turn on message dumping for the next 100 messages  </li>
<li>
<b>10s</b> : turn on message dumping for the next 10 seconds  </li>
</ul>
<p>Note that above, <code>100</code> and <code>10</code> numerical values are for just for illustration purposes, and application can choose an appropriate value for them. Also note that pattern is case-insensitive. Return zero if <code>command</code> is valid and message dumping has been configured, non-zero value otherwise. The behavior is undefined unless the session has been started. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1MockSession.html#a802d9ad2faa75ea6abdb570c35a18c2e">bmqa::MockSession</a>, and <a class="el" href="classbmqa_1_1Session.html#a0600029292f5b33d5b22f9a7afab5c72">bmqa::Session</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bmqa__abstractsession_8h_source.html">bmqa_abstractsession.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Jun 15 2023 11:58:51 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
