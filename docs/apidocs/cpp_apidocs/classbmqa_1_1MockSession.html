<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Class bmqa::MockSession</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="bdedox.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bmqa.html" target="_blank">bmqa</a> | <a class="qindex" href="group__bmqpi.html" target="_blank">bmqpi</a> | <a class="qindex" href="group__bmqt.html" target="_blank">bmqt</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="components.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebmqa.html">bmqa</a>      </li>
      <li><a class="el" href="classbmqa_1_1MockSession.html">bmqa::MockSession</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bmqa::MockSession Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bmqa::MockSession" --><!-- doxytag: inherits="bmqa::AbstractSession" -->
<p><code>#include &lt;<a class="el" href="bmqa__mocksession_8h_source.html">bmqa_mocksession.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for bmqa::MockSession:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbmqa_1_1MockSession.png" usemap="#bmqa::MockSession_map" alt=""/>
  <map id="bmqa::MockSession_map" name="bmqa::MockSession_map">
<area href="classbmqa_1_1AbstractSession.html" alt="bmqa::AbstractSession" shape="rect" coords="0,0,138,24"/>
</map>
</div>

<p><a href="classbmqa_1_1MockSession-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>Call</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>Job</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void(const <br class="typebreak"/>
char *description, const char <br class="typebreak"/>
*file, int line)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a9ec7f395b2a5079ff32170751941627d">FailureCb</a> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void(const <br class="typebreak"/>
<a class="el" href="classbmqa_1_1OpenQueueStatus.html">bmqa::OpenQueueStatus</a> &amp;result)&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a75e7237336027136889801133334b72d">OpenQueueCallback</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void(const <br class="typebreak"/>
<a class="el" href="classbmqa_1_1ConfigureQueueStatus.html">bmqa::ConfigureQueueStatus</a> <br class="typebreak"/>
&amp;result)&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a0a63dcba9d8cabae9bb083865db83c20">ConfigureQueueCallback</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void(const <br class="typebreak"/>
<a class="el" href="classbmqa_1_1CloseQueueStatus.html">bmqa::CloseQueueStatus</a> &amp;result)&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1AbstractSession.html#a657f8f6d3779ef7b5697be304e8415c6">CloseQueueCallback</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#ac6616abbb29233f47d61b8c3bd69966b">MockSession</a> (const <a class="el" href="classbmqt_1_1SessionOptions.html">bmqt::SessionOptions</a> &amp;options=<a class="el" href="classbmqt_1_1SessionOptions.html">bmqt::SessionOptions</a>(), bslma::Allocator *allocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#adc1b5ac028d9c774b89776ad428a850a">MockSession</a> (bslma::ManagedPtr&lt; <a class="el" href="classbmqa_1_1SessionEventHandler.html">SessionEventHandler</a> &gt; eventHandler, const <a class="el" href="classbmqt_1_1SessionOptions.html">bmqt::SessionOptions</a> &amp;options=<a class="el" href="classbmqt_1_1SessionOptions.html">bmqt::SessionOptions</a>(), bslma::Allocator *allocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a1ec3b3181cfbd68adc6da3734f386a45">~MockSession</a> () BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a8016785f6a8ad9447ea0772937d35a4a">enqueueEvent</a> (const <a class="el" href="classbmqa_1_1Event.html">bmqa::Event</a> &amp;event)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a7fffd765e8aeda9343ea0f74d0c2509c">emitEvent</a> (int numEvents=1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Call &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#abaf1b757e9be63515e242222480253b8">expect_start</a> (const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Call &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a0a96f26acc846559a7dab7f149c56d6f">expect_startAsync</a> (const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Call &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a5e2df33be0157d1579cca50e0a347941">expect_stop</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Call &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a7e1a1b4a3d449a3d1d82d7960673fb45">expect_stopAsync</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Call &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#ab1c92baa2d8b8b94096b9637eff9a82e">expect_finalizeStop</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Call &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a0f7ba6fd0559a7429e2e2943b44b76df">expect_openQueue</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;uri, bsls::Types::Uint64 flags, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options=<a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Call &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#ad6fe5d4f81ccd7149f478774778a3ae8">expect_openQueueSync</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;uri, bsls::Types::Uint64 flags, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options=<a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Call &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#afd5fefd1a69a104de528d4c2e86e6d24">expect_openQueueAsync</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;uri, bsls::Types::Uint64 flags, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options=<a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Call &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a2c36bb97134f582dc39358f0e8d8ab56">expect_openQueueAsync</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;uri, bsls::Types::Uint64 flags, const <a class="el" href="classbmqa_1_1AbstractSession.html#a75e7237336027136889801133334b72d">OpenQueueCallback</a> &amp;callback, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options=<a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Call &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#abbd17e1280f3e6b9fb082a18175e72b0">expect_closeQueue</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Call &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#aeaa22999622bb9e0f96f24dcffd086a9">expect_closeQueueSync</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Call &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a4a638a48758ab0169ef1a0040ee8b4bf">expect_closeQueueAsync</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Call &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a94446f1db8b733681301f4af8c822400">expect_closeQueueAsync</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqa_1_1AbstractSession.html#a657f8f6d3779ef7b5697be304e8415c6">CloseQueueCallback</a> &amp;callback, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Call &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#affbf502aecc4822cee93aa60df135a94">expect_configureQueue</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options=<a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Call &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#aaa8e2a6ff675e4fcdb83884ea20feb7d">expect_configureQueueSync</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options=<a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Call &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#acd82dd36c49d7ce64559ca341a4866d2">expect_configureQueueAsync</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options=<a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Call &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#adc0bf96bb12a056a7c6ffbdf90a3a286">expect_configureQueueAsync</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options, const <a class="el" href="classbmqa_1_1AbstractSession.html#a0a63dcba9d8cabae9bb083865db83c20">ConfigureQueueCallback</a> &amp;callback, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Call &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#ab03406861bdb6970618dd6132cebbd0a">expect_nextEvent</a> (const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Call &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a437de5105b720ef76e15c18b6d7c65be">expect_post</a> (const <a class="el" href="classbmqa_1_1MessageEvent.html">MessageEvent</a> &amp;messageEvent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Call &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a057890904dd7b08747740f753c18b209">expect_confirmMessage</a> (const <a class="el" href="classbmqa_1_1Message.html">Message</a> &amp;message)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Call &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a1e5fefe16c32f12f62b07effdf471a14">expect_confirmMessage</a> (const <a class="el" href="classbmqa_1_1MessageConfirmationCookie.html">MessageConfirmationCookie</a> &amp;cookie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Call &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a30432cb73aaef11a8edebdd947a93655">expect_confirmMessages</a> (<a class="el" href="classbmqa_1_1ConfirmEventBuilder.html">ConfirmEventBuilder</a> *builder)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a3ccee44dfcfd49715bd0117789a18800">start</a> (const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a82c46ae947da30980239a2f74f20ecc9">startAsync</a> (const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a8dc6733c0ebe7d7595d743ad2f3bb722">stop</a> () BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#ae29ebfed50a62dc98c05145cc1734e97">stopAsync</a> () BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a79319928a7edcc5f20c31458b8cf2611">finalizeStop</a> () BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a9633da94c262bb82ff74133532c1e07a">loadMessageEventBuilder</a> (<a class="el" href="classbmqa_1_1MessageEventBuilder.html">MessageEventBuilder</a> *builder) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#ae7cc10715077b9f3cd2d4d577b77352b">loadConfirmEventBuilder</a> (<a class="el" href="classbmqa_1_1ConfirmEventBuilder.html">ConfirmEventBuilder</a> *builder) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#ae21e898c9d668653f7ac9960722aa348">loadMessageProperties</a> (<a class="el" href="classbmqa_1_1MessageProperties.html">MessageProperties</a> *buffer) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#ad57bb8b0fc70a5fee325dd855760c478">getQueueId</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;uri) const BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a47da4b4df84373fde60e733e032f995b">getQueueId</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1CorrelationId.html">bmqt::CorrelationId</a> &amp;correlationId) const BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#aa8af7af8371bc818ef162e4cd03c4909">openQueue</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;uri, bsls::Types::Uint64 flags, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options=<a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbmqa_1_1OpenQueueStatus.html">OpenQueueStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#abfd516749dbd4c8e412b23ce4f851d35">openQueueSync</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;uri, bsls::Types::Uint64 flags, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options=<a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a4fa5863373125d2cdca72dcf7e5a3ae4">openQueueAsync</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;uri, bsls::Types::Uint64 flags, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options=<a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a134cbd47f159b10b65040ae4dd076db4">openQueueAsync</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;uri, bsls::Types::Uint64 flags, const <a class="el" href="classbmqa_1_1AbstractSession.html#a75e7237336027136889801133334b72d">OpenQueueCallback</a> &amp;callback, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options=<a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a68b18cc9c0eff992a3536c4988c96251">configureQueue</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options=<a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbmqa_1_1ConfigureQueueStatus.html">ConfigureQueueStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a4986cbd66587a026565c8663efd62bb2">configureQueueSync</a> (const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options, const bsls::TimeInterval &amp;timeout) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#ae352999956a9a8a68179a714fe0c3306">configureQueueAsync</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options=<a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a3845bef0c8ca02fd737fe975815f354f">configureQueueAsync</a> (const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options, const <a class="el" href="classbmqa_1_1AbstractSession.html#a0a63dcba9d8cabae9bb083865db83c20">ConfigureQueueCallback</a> &amp;callback, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a8cecfb0853dd4fe41e246fb9905cc95e">closeQueue</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbmqa_1_1CloseQueueStatus.html">CloseQueueStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a1a016fc12d2039ca3efdf01b287714dc">closeQueueSync</a> (const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#ac1b6fe877b8711b489428613a55d7d2c">closeQueueAsync</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#acf330edf0bab3cae2b13da59736fd8ef">closeQueueAsync</a> (const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqa_1_1AbstractSession.html#a657f8f6d3779ef7b5697be304e8415c6">CloseQueueCallback</a> &amp;callback, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbmqa_1_1Event.html">Event</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#aabdfafe3f69ab8ae30559f9b39336376">nextEvent</a> (const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#aa9b85b4355f83b4f33e7381f131c5ab4">post</a> (const <a class="el" href="classbmqa_1_1MessageEvent.html">MessageEvent</a> &amp;messageEvent) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#aa0e92d35e2a134a88144aadef4a390b8">confirmMessage</a> (const <a class="el" href="classbmqa_1_1Message.html">Message</a> &amp;message) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a0b29178d3c4b2c125289d498d242be11">confirmMessage</a> (const <a class="el" href="classbmqa_1_1MessageConfirmationCookie.html">MessageConfirmationCookie</a> &amp;cookie) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a38634ff51f7ef256616b581086ff657f">confirmMessages</a> (<a class="el" href="classbmqa_1_1ConfirmEventBuilder.html">ConfirmEventBuilder</a> *builder) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a802d9ad2faa75ea6abdb570c35a18c2e">configureMessageDumping</a> (const bslstl::StringRef &amp;command) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#ad0c3ac8a0893946607207c68f8bfa856">setFailureCallback</a> (const <a class="el" href="classbmqa_1_1MockSession.html#a9ec7f395b2a5079ff32170751941627d">FailureCb</a> &amp;failureCb)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a2cf3158b9ba9f7a07960f3429639f170">popPostedEvent</a> (<a class="el" href="classbmqa_1_1MessageEvent.html">bmqa::MessageEvent</a> *event)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a87a7155dcd25e4d7a56aa839274ff26d">unconfirmedMessages</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#af675c02f44e358d822da6056e87eca1e">initialize</a> (bslma::Allocator *allocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1MockSession.html#a473acc6486cd2ff28f523dee03334c8d">shutdown</a> ()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Mechanism to mock a <code><a class="el" href="classbmqa_1_1Session.html">bmqa::Session</a></code></p>
<p>See <a class="el" href="group__bmqa__mocksession.html">Component bmqa_mocksession</a> </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a9ec7f395b2a5079ff32170751941627d"></a><!-- doxytag: member="bmqa::MockSession::FailureCb" ref="a9ec7f395b2a5079ff32170751941627d" args=")" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void (const char *description, const char *file, int line) <a class="el" href="classbmqa_1_1MockSession.html#a9ec7f395b2a5079ff32170751941627d">bmqa::MockSession::FailureCb</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Callback used to inform the test driver of an assertion failure. The application test driver using the <code><a class="el" href="classbmqa_1_1MockSession.html">MockSession</a></code> may provide an implementation that makes the test driver fail (for instance, calling BDE's test driver ASSERT macro). </p>

</div>
</div>
<a class="anchor" id="a75e7237336027136889801133334b72d"></a><!-- doxytag: member="bmqa::MockSession::OpenQueueCallback" ref="a75e7237336027136889801133334b72d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void(const <a class="el" href="classbmqa_1_1OpenQueueStatus.html">bmqa::OpenQueueStatus</a>&amp; result)&gt; <a class="el" href="classbmqa_1_1AbstractSession.html#a75e7237336027136889801133334b72d">bmqa::AbstractSession::OpenQueueCallback</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoked as a response to an asynchronous open queue operation, <code>OpenQueueCallback</code> is an alias for a callback function object (functor) that takes as an argument the specified <code>result</code>, providing the result and context of the requested operation. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1Session.html#a4287dbcc814771d709b3d48094641519">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a0a63dcba9d8cabae9bb083865db83c20"></a><!-- doxytag: member="bmqa::MockSession::ConfigureQueueCallback" ref="a0a63dcba9d8cabae9bb083865db83c20" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void(const <a class="el" href="classbmqa_1_1ConfigureQueueStatus.html">bmqa::ConfigureQueueStatus</a>&amp; result)&gt; <a class="el" href="classbmqa_1_1AbstractSession.html#a0a63dcba9d8cabae9bb083865db83c20">bmqa::AbstractSession::ConfigureQueueCallback</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoked as a response to an asynchronous configure queue operation, <code>ConfigureQueueCallback</code> is an alias for a callback function object (functor) that takes as an argument the specified <code>result</code>, providing the result and context of the requested operation. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1Session.html#aade4d05e446e2bc2a93f5821d8d508e7">bmqa::Session</a>.</p>

</div>
</div>
<a class="anchor" id="a657f8f6d3779ef7b5697be304e8415c6"></a><!-- doxytag: member="bmqa::MockSession::CloseQueueCallback" ref="a657f8f6d3779ef7b5697be304e8415c6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void(const <a class="el" href="classbmqa_1_1CloseQueueStatus.html">bmqa::CloseQueueStatus</a>&amp; result)&gt; <a class="el" href="classbmqa_1_1AbstractSession.html#a657f8f6d3779ef7b5697be304e8415c6">bmqa::AbstractSession::CloseQueueCallback</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoked as a response to an asynchronous close queue operation, <code>CloseQueueCallback</code> is an alias for a callback function object (functor) that takes as an argument the specified <code>result</code>, providing the result and context of the requested operation. </p>

<p>Reimplemented in <a class="el" href="classbmqa_1_1Session.html#af8b2998c51e4a9f8d83ecf9a9751a8e7">bmqa::Session</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac6616abbb29233f47d61b8c3bd69966b"></a><!-- doxytag: member="bmqa::MockSession::MockSession" ref="ac6616abbb29233f47d61b8c3bd69966b" args="(const bmqt::SessionOptions &amp;options=bmqt::SessionOptions(), bslma::Allocator *allocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bmqa::MockSession::MockSession </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1SessionOptions.html">bmqt::SessionOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1SessionOptions.html">bmqt::SessionOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new <code><a class="el" href="classbmqa_1_1MockSession.html">MockSession</a></code> in <em>synchronous</em> mode using the optionally specified <code>options</code>. In such mode, events have to be fetched by the application using the <code><a class="el" href="classbmqa_1_1MockSession.html#aabdfafe3f69ab8ae30559f9b39336376">nextEvent()</a></code> method. Optionally specify an <code>allocator</code> used to supply memory. If <code>allocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="adc1b5ac028d9c774b89776ad428a850a"></a><!-- doxytag: member="bmqa::MockSession::MockSession" ref="adc1b5ac028d9c774b89776ad428a850a" args="(bslma::ManagedPtr&lt; SessionEventHandler &gt; eventHandler, const bmqt::SessionOptions &amp;options=bmqt::SessionOptions(), bslma::Allocator *allocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bmqa::MockSession::MockSession </td>
          <td>(</td>
          <td class="paramtype">bslma::ManagedPtr&lt; <a class="el" href="classbmqa_1_1SessionEventHandler.html">SessionEventHandler</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>eventHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1SessionOptions.html">bmqt::SessionOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1SessionOptions.html">bmqt::SessionOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code><a class="el" href="classbmqa_1_1MockSession.html">MockSession</a></code> in <em>asynchronous</em> mode using the specified <code>eventHandler</code> as callback for event processing and the optionally specified <code>options</code>. Optionally specify an <code>allocator</code> used to supply memory. If the optionally specified <code>allocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="a1ec3b3181cfbd68adc6da3734f386a45"></a><!-- doxytag: member="bmqa::MockSession::~MockSession" ref="a1ec3b3181cfbd68adc6da3734f386a45" args="() BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bmqa::MockSession::~MockSession </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stop the <code><a class="el" href="classbmqa_1_1MockSession.html">MockSession</a></code> and destroy this object. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af675c02f44e358d822da6056e87eca1e"></a><!-- doxytag: member="bmqa::MockSession::initialize" ref="af675c02f44e358d822da6056e87eca1e" args="(bslma::Allocator *allocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bmqa::MockSession::initialize </td>
          <td>(</td>
          <td class="paramtype">bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Perform a one time initialization needed by components used in <code><a class="el" href="classbmqa_1_1MockSession.html">MockSession</a></code> and <code><a class="el" href="structbmqa_1_1MockSessionUtil.html">MockSessionUtil</a></code>. This method only needs to be called once before any other method, but can be called multiple times provided that for each call to <code>initialize</code> there is a corresponding call to <code>shutdown</code>. Use the optionally specified <code>allocator</code> for any memory allocation, or the <code>global</code> allocator if none is provided. Note that specifying the allocator is provided for test drivers only, and therefore users should let it default to the global allocator. NOTE: This method will need to be invoked only if the application needs to use <code><a class="el" href="structbmqa_1_1MockSessionUtil.html">MockSessionUtil</a></code> outside the scope of <code><a class="el" href="classbmqa_1_1MockSession.html">MockSession</a></code>. </p>

</div>
</div>
<a class="anchor" id="a473acc6486cd2ff28f523dee03334c8d"></a><!-- doxytag: member="bmqa::MockSession::shutdown" ref="a473acc6486cd2ff28f523dee03334c8d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bmqa::MockSession::shutdown </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pendant operation of the <code>initialize</code> one. The number of calls to <code>shutdown</code> must equal the number of calls to <code>initialize</code>, without corresponding <code>shutdown</code> calls, to fully destroy the objects. It is safe to call <code>initialize</code> after calling <code>shutdown</code>. The behaviour is undefined if <code>shutdown</code> is called without <code>initialize</code> first being called. </p>

</div>
</div>
<a class="anchor" id="a8016785f6a8ad9447ea0772937d35a4a"></a><!-- doxytag: member="bmqa::MockSession::enqueueEvent" ref="a8016785f6a8ad9447ea0772937d35a4a" args="(const bmqa::Event &amp;event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bmqa::MockSession::enqueueEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1Event.html">bmqa::Event</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enqueue the specified <code>event</code> in the queue of events to be emitted. NOTE: This method is unique to <code><a class="el" href="classbmqa_1_1MockSession.html">MockSession</a></code> and is valid only in unit tests. </p>

</div>
</div>
<a class="anchor" id="a7fffd765e8aeda9343ea0f74d0c2509c"></a><!-- doxytag: member="bmqa::MockSession::emitEvent" ref="a7fffd765e8aeda9343ea0f74d0c2509c" args="(int numEvents=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bmqa::MockSession::emitEvent </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numEvents</em> = <code>1</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Emit the specified number of <code>numEvents</code> from the queue of events to be emitted. Return true if at least one event was emitted, and false otherwise. NOTE: This method is unique to <code><a class="el" href="classbmqa_1_1MockSession.html">MockSession</a></code> and is valid only in unit tests. </p>

</div>
</div>
<a class="anchor" id="abaf1b757e9be63515e242222480253b8"></a><!-- doxytag: member="bmqa::MockSession::expect_start" ref="abaf1b757e9be63515e242222480253b8" args="(const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Call&amp; bmqa::MockSession::expect_start </td>
          <td>(</td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0a96f26acc846559a7dab7f149c56d6f"></a><!-- doxytag: member="bmqa::MockSession::expect_startAsync" ref="a0a96f26acc846559a7dab7f149c56d6f" args="(const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Call&amp; bmqa::MockSession::expect_startAsync </td>
          <td>(</td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5e2df33be0157d1579cca50e0a347941"></a><!-- doxytag: member="bmqa::MockSession::expect_stop" ref="a5e2df33be0157d1579cca50e0a347941" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Call&amp; bmqa::MockSession::expect_stop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7e1a1b4a3d449a3d1d82d7960673fb45"></a><!-- doxytag: member="bmqa::MockSession::expect_stopAsync" ref="a7e1a1b4a3d449a3d1d82d7960673fb45" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Call&amp; bmqa::MockSession::expect_stopAsync </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab1c92baa2d8b8b94096b9637eff9a82e"></a><!-- doxytag: member="bmqa::MockSession::expect_finalizeStop" ref="ab1c92baa2d8b8b94096b9637eff9a82e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Call&amp; bmqa::MockSession::expect_finalizeStop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0f7ba6fd0559a7429e2e2943b44b76df"></a><!-- doxytag: member="bmqa::MockSession::expect_openQueue" ref="a0f7ba6fd0559a7429e2e2943b44b76df" args="(QueueId *queueId, const bmqt::Uri &amp;uri, bsls::Types::Uint64 flags, const bmqt::QueueOptions &amp;options=bmqt::QueueOptions(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Call&amp; bmqa::MockSession::expect_openQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsls::Types::Uint64&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad6fe5d4f81ccd7149f478774778a3ae8"></a><!-- doxytag: member="bmqa::MockSession::expect_openQueueSync" ref="ad6fe5d4f81ccd7149f478774778a3ae8" args="(QueueId *queueId, const bmqt::Uri &amp;uri, bsls::Types::Uint64 flags, const bmqt::QueueOptions &amp;options=bmqt::QueueOptions(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Call&amp; bmqa::MockSession::expect_openQueueSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsls::Types::Uint64&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afd5fefd1a69a104de528d4c2e86e6d24"></a><!-- doxytag: member="bmqa::MockSession::expect_openQueueAsync" ref="afd5fefd1a69a104de528d4c2e86e6d24" args="(QueueId *queueId, const bmqt::Uri &amp;uri, bsls::Types::Uint64 flags, const bmqt::QueueOptions &amp;options=bmqt::QueueOptions(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Call&amp; bmqa::MockSession::expect_openQueueAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsls::Types::Uint64&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2c36bb97134f582dc39358f0e8d8ab56"></a><!-- doxytag: member="bmqa::MockSession::expect_openQueueAsync" ref="a2c36bb97134f582dc39358f0e8d8ab56" args="(QueueId *queueId, const bmqt::Uri &amp;uri, bsls::Types::Uint64 flags, const OpenQueueCallback &amp;callback, const bmqt::QueueOptions &amp;options=bmqt::QueueOptions(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Call&amp; bmqa::MockSession::expect_openQueueAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsls::Types::Uint64&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1AbstractSession.html#a75e7237336027136889801133334b72d">OpenQueueCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abbd17e1280f3e6b9fb082a18175e72b0"></a><!-- doxytag: member="bmqa::MockSession::expect_closeQueue" ref="abbd17e1280f3e6b9fb082a18175e72b0" args="(QueueId *queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Call&amp; bmqa::MockSession::expect_closeQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aeaa22999622bb9e0f96f24dcffd086a9"></a><!-- doxytag: member="bmqa::MockSession::expect_closeQueueSync" ref="aeaa22999622bb9e0f96f24dcffd086a9" args="(QueueId *queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Call&amp; bmqa::MockSession::expect_closeQueueSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4a638a48758ab0169ef1a0040ee8b4bf"></a><!-- doxytag: member="bmqa::MockSession::expect_closeQueueAsync" ref="a4a638a48758ab0169ef1a0040ee8b4bf" args="(QueueId *queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Call&amp; bmqa::MockSession::expect_closeQueueAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a94446f1db8b733681301f4af8c822400"></a><!-- doxytag: member="bmqa::MockSession::expect_closeQueueAsync" ref="a94446f1db8b733681301f4af8c822400" args="(QueueId *queueId, const CloseQueueCallback &amp;callback, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Call&amp; bmqa::MockSession::expect_closeQueueAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1AbstractSession.html#a657f8f6d3779ef7b5697be304e8415c6">CloseQueueCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="affbf502aecc4822cee93aa60df135a94"></a><!-- doxytag: member="bmqa::MockSession::expect_configureQueue" ref="affbf502aecc4822cee93aa60df135a94" args="(QueueId *queueId, const bmqt::QueueOptions &amp;options=bmqt::QueueOptions(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Call&amp; bmqa::MockSession::expect_configureQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aaa8e2a6ff675e4fcdb83884ea20feb7d"></a><!-- doxytag: member="bmqa::MockSession::expect_configureQueueSync" ref="aaa8e2a6ff675e4fcdb83884ea20feb7d" args="(QueueId *queueId, const bmqt::QueueOptions &amp;options=bmqt::QueueOptions(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Call&amp; bmqa::MockSession::expect_configureQueueSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acd82dd36c49d7ce64559ca341a4866d2"></a><!-- doxytag: member="bmqa::MockSession::expect_configureQueueAsync" ref="acd82dd36c49d7ce64559ca341a4866d2" args="(QueueId *queueId, const bmqt::QueueOptions &amp;options=bmqt::QueueOptions(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Call&amp; bmqa::MockSession::expect_configureQueueAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adc0bf96bb12a056a7c6ffbdf90a3a286"></a><!-- doxytag: member="bmqa::MockSession::expect_configureQueueAsync" ref="adc0bf96bb12a056a7c6ffbdf90a3a286" args="(QueueId *queueId, const bmqt::QueueOptions &amp;options, const ConfigureQueueCallback &amp;callback, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Call&amp; bmqa::MockSession::expect_configureQueueAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1AbstractSession.html#a0a63dcba9d8cabae9bb083865db83c20">ConfigureQueueCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab03406861bdb6970618dd6132cebbd0a"></a><!-- doxytag: member="bmqa::MockSession::expect_nextEvent" ref="ab03406861bdb6970618dd6132cebbd0a" args="(const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Call&amp; bmqa::MockSession::expect_nextEvent </td>
          <td>(</td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a437de5105b720ef76e15c18b6d7c65be"></a><!-- doxytag: member="bmqa::MockSession::expect_post" ref="a437de5105b720ef76e15c18b6d7c65be" args="(const MessageEvent &amp;messageEvent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Call&amp; bmqa::MockSession::expect_post </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1MessageEvent.html">MessageEvent</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>messageEvent</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a057890904dd7b08747740f753c18b209"></a><!-- doxytag: member="bmqa::MockSession::expect_confirmMessage" ref="a057890904dd7b08747740f753c18b209" args="(const Message &amp;message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Call&amp; bmqa::MockSession::expect_confirmMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1Message.html">Message</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>message</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1e5fefe16c32f12f62b07effdf471a14"></a><!-- doxytag: member="bmqa::MockSession::expect_confirmMessage" ref="a1e5fefe16c32f12f62b07effdf471a14" args="(const MessageConfirmationCookie &amp;cookie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Call&amp; bmqa::MockSession::expect_confirmMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1MessageConfirmationCookie.html">MessageConfirmationCookie</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cookie</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a30432cb73aaef11a8edebdd947a93655"></a><!-- doxytag: member="bmqa::MockSession::expect_confirmMessages" ref="a30432cb73aaef11a8edebdd947a93655" args="(ConfirmEventBuilder *builder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Call&amp; bmqa::MockSession::expect_confirmMessages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1ConfirmEventBuilder.html">ConfirmEventBuilder</a> *&nbsp;</td>
          <td class="paramname"> <em>builder</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Expect a call to the function and return a reference offering modifiable access to the corresponding <code>Call</code> object.</p>
<p>NOTE: Do not use these method directly, use the macro <code>BMQA_EXPECT_CALL</code> instead. </p>

</div>
</div>
<a class="anchor" id="a3ccee44dfcfd49715bd0117789a18800"></a><!-- doxytag: member="bmqa::MockSession::start" ref="a3ccee44dfcfd49715bd0117789a18800" args="(const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::MockSession::start </td>
          <td>(</td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connect to the BlazingMQ broker and start the message processing for this <code><a class="el" href="classbmqa_1_1Session.html">Session</a></code>. This method blocks until either the <code><a class="el" href="classbmqa_1_1Session.html">Session</a></code> is connected to the broker, fails to connect, or the operation times out. If the optionally specified <code>timeout</code> is not populated, use the one defined in the session options. Return 0 on success, or a non-zero value corresponding to the <code><a class="el" href="structbmqt_1_1GenericResult.html#a637624d4e7f6e21b9411b630769286cc">bmqt::GenericResult::Enum</a></code> enum values otherwise. The behavior is undefined if this method is called on an already started <code><a class="el" href="classbmqa_1_1Session.html">Session</a></code>. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a88337ae19f335352f32f98818d2d82e9">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a82c46ae947da30980239a2f74f20ecc9"></a><!-- doxytag: member="bmqa::MockSession::startAsync" ref="a82c46ae947da30980239a2f74f20ecc9" args="(const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::MockSession::startAsync </td>
          <td>(</td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Start the <code><a class="el" href="classbmqa_1_1MockSession.html">MockSession</a></code> with an optionally specified <code>timeout</code>. The return values are elucidated in <code><a class="el" href="structbmqt_1_1GenericResult.html">bmqt::GenericResult</a></code>. In general a call to <code>start</code> or <code>startAsync</code> emits a <code><a class="el" href="classbmqa_1_1SessionEvent.html">SessionEvent</a></code> of type <code>e_CONNECTED</code> or <code>e_CONNECTION_TIMEOUT</code>. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a42ba613e230863b89cd8f31413b9afc0">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a8dc6733c0ebe7d7595d743ad2f3bb722"></a><!-- doxytag: member="bmqa::MockSession::stop" ref="a8dc6733c0ebe7d7595d743ad2f3bb722" args="() BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bmqa::MockSession::stop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gracefully disconnect from the BlazingMQ broker and stop the operation of this <code><a class="el" href="classbmqa_1_1Session.html">Session</a></code>. This method blocks waiting for all already invoked event handlers to exit and all session-related operations to be finished. No other method but <code><a class="el" href="classbmqa_1_1MockSession.html#a3ccee44dfcfd49715bd0117789a18800">start()</a></code> may be used after this method returns. This method must <em>NOT</em> be called if the session is in synchronous mode (i.e., not using the EventHandler), <code><a class="el" href="classbmqa_1_1MockSession.html#ae29ebfed50a62dc98c05145cc1734e97">stopAsync()</a></code> should be called in this case. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a39b54dd9aff5fb0165dfb382641f7606">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="ae29ebfed50a62dc98c05145cc1734e97"></a><!-- doxytag: member="bmqa::MockSession::stopAsync" ref="ae29ebfed50a62dc98c05145cc1734e97" args="() BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bmqa::MockSession::stopAsync </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stop the <code><a class="el" href="classbmqa_1_1MockSession.html">MockSession</a></code>. In general a call to <code>start</code> or <code>startAsync</code> emits a <code><a class="el" href="classbmqa_1_1SessionEvent.html">SessionEvent</a></code> of type <code>e_DISCONNECTED</code> or <code>e_CONNECTION_TIMEOUT</code>. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a6431f6eee936f03b40fa33385832824a">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a79319928a7edcc5f20c31458b8cf2611"></a><!-- doxytag: member="bmqa::MockSession::finalizeStop" ref="a79319928a7edcc5f20c31458b8cf2611" args="() BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bmqa::MockSession::finalizeStop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is only to be used if the session is in synchronous mode (i.e., not using the EventHandler): it must be called once all threads getting events with <code><a class="el" href="classbmqa_1_1MockSession.html#aabdfafe3f69ab8ae30559f9b39336376">nextEvent()</a></code> have been joined. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a5a790a8e3881e37740023204ea5f71fa">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a9633da94c262bb82ff74133532c1e07a"></a><!-- doxytag: member="bmqa::MockSession::loadMessageEventBuilder" ref="a9633da94c262bb82ff74133532c1e07a" args="(MessageEventBuilder *builder) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bmqa::MockSession::loadMessageEventBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1MessageEventBuilder.html">MessageEventBuilder</a> *&nbsp;</td>
          <td class="paramname"> <em>builder</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load the <code><a class="el" href="classbmqa_1_1MessageEventBuilder.html">MessageEventBuilder</a></code> into the specified <code>builder</code> output parameter. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#acee2b8777224bfb88f59904551c69755">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="ae7cc10715077b9f3cd2d4d577b77352b"></a><!-- doxytag: member="bmqa::MockSession::loadConfirmEventBuilder" ref="ae7cc10715077b9f3cd2d4d577b77352b" args="(ConfirmEventBuilder *builder) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bmqa::MockSession::loadConfirmEventBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1ConfirmEventBuilder.html">ConfirmEventBuilder</a> *&nbsp;</td>
          <td class="paramname"> <em>builder</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load the <code><a class="el" href="classbmqa_1_1ConfirmEventBuilder.html">ConfirmEventBuilder</a></code> into the specified <code>builder</code> output parameter. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a0662d3695901ef024ea773abf8a50482">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="ae21e898c9d668653f7ac9960722aa348"></a><!-- doxytag: member="bmqa::MockSession::loadMessageProperties" ref="ae21e898c9d668653f7ac9960722aa348" args="(MessageProperties *buffer) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bmqa::MockSession::loadMessageProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1MessageProperties.html">MessageProperties</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load the <code><a class="el" href="classbmqa_1_1MessageProperties.html">MessageProperties</a></code> into the specified <code>buffer</code> output parameter. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#ab5b6459aa7eb97c5a058ef9a8f1f6409">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="ad57bb8b0fc70a5fee325dd855760c478"></a><!-- doxytag: member="bmqa::MockSession::getQueueId" ref="ad57bb8b0fc70a5fee325dd855760c478" args="(QueueId *queueId, const bmqt::Uri &amp;uri) const BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::MockSession::getQueueId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uri</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load <code><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a></code> object associated with the specified <code>uri</code> into the specified <code>queueId</code> output parameter. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a897bf80e972bd2d8d356c89ac7960431">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a47da4b4df84373fde60e733e032f995b"></a><!-- doxytag: member="bmqa::MockSession::getQueueId" ref="a47da4b4df84373fde60e733e032f995b" args="(QueueId *queueId, const bmqt::CorrelationId &amp;correlationId) const BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::MockSession::getQueueId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1CorrelationId.html">bmqt::CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load <code><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a></code> object associated with the specified <code>correlationId</code> into the specified <code>queueId</code> output parameter. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#af07daee8b4e090189aa719c896e1e14f">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="aa8af7af8371bc818ef162e4cd03c4909"></a><!-- doxytag: member="bmqa::MockSession::openQueue" ref="aa8af7af8371bc818ef162e4cd03c4909" args="(QueueId *queueId, const bmqt::Uri &amp;uri, bsls::Types::Uint64 flags, const bmqt::QueueOptions &amp;options=bmqt::QueueOptions(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::MockSession::openQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsls::Types::Uint64&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DEPRECATED: Use the <code>openQueueSync(<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId...)</code> instead. This method will be marked as <code>BSLS_ANNOTATION_DEPRECATED</code> in future release of libbmq. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a24e5640b6226a6ff8d43a0d4015f0b16">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="abfd516749dbd4c8e412b23ce4f851d35"></a><!-- doxytag: member="bmqa::MockSession::openQueueSync" ref="abfd516749dbd4c8e412b23ce4f851d35" args="(QueueId *queueId, const bmqt::Uri &amp;uri, bsls::Types::Uint64 flags, const bmqt::QueueOptions &amp;options=bmqt::QueueOptions(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbmqa_1_1OpenQueueStatus.html">OpenQueueStatus</a> bmqa::MockSession::openQueueSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsls::Types::Uint64&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Open the queue having the specified <code>uri</code> with the specified <code>flags</code> (a combination of the values defined in <code><a class="el" href="structbmqt_1_1QueueFlags.html#a7f1a1e2ba9084565388e19bc1921a4f2">bmqt::QueueFlags::Enum</a></code>), using the specified <code>queueId</code> to correlate events related to that queue. The object <code>queueId</code> referring to is modified, so the <code>queueId</code> represents the actual queue uri, flags and options. Return a result providing the status and context of the operation. Use the optionally specified <code>options</code> to configure some advanced settings. In general, a call to <code>openQueueSync</code> emits nothing. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a7facfe47066415f6977ef6b78547ca43">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a4fa5863373125d2cdca72dcf7e5a3ae4"></a><!-- doxytag: member="bmqa::MockSession::openQueueAsync" ref="a4fa5863373125d2cdca72dcf7e5a3ae4" args="(QueueId *queueId, const bmqt::Uri &amp;uri, bsls::Types::Uint64 flags, const bmqt::QueueOptions &amp;options=bmqt::QueueOptions(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::MockSession::openQueueAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsls::Types::Uint64&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DEPRECATED: Use the <code>openQueueAsync(...)</code> with callback flavor instead. This method will be marked as <code>BSLS_ANNOTATION_DEPRECATED</code> in future release of libbmq. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a9c526171c5bf03bd1b3ea993bdc7fabc">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a134cbd47f159b10b65040ae4dd076db4"></a><!-- doxytag: member="bmqa::MockSession::openQueueAsync" ref="a134cbd47f159b10b65040ae4dd076db4" args="(QueueId *queueId, const bmqt::Uri &amp;uri, bsls::Types::Uint64 flags, const OpenQueueCallback &amp;callback, const bmqt::QueueOptions &amp;options=bmqt::QueueOptions(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bmqa::MockSession::openQueueAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsls::Types::Uint64&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1AbstractSession.html#a75e7237336027136889801133334b72d">OpenQueueCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously open the queue having the specified <code>uri</code> with the specified <code>flags</code> (a combination of the values defined in <code><a class="el" href="structbmqt_1_1QueueFlags.html#a7f1a1e2ba9084565388e19bc1921a4f2">bmqt::QueueFlags::Enum</a></code>). The object <code>queueId</code> referring to is modified, so the <code>queueId</code> represents the actual queue uri, flags and options. The result of the operation is communicated to the specified <code>callback</code> via a <code><a class="el" href="classbmqa_1_1OpenQueueStatus.html">bmqa::OpenQueueStatus</a></code>, providing an automatically generated correlation <code>queueId</code> and the status and context of the requested operation. Use the optionally specified <code>options</code> to configure some advanced settings. In general, a call to <code>openQueueAsync</code> does not emit a <code><a class="el" href="classbmqa_1_1SessionEvent.html">SessionEvent</a></code>, but rather invokes the <code>callback</code> (if provided) instead when the corresponding <code>emitEvent</code> is called.</p>
<p>NOTE: <code>openQueueAsync</code> updates the queue state to <code>e_OPENING</code> which is further updated upon invocation of the <code>callback</code> (if provided) with a successful <code><a class="el" href="classbmqa_1_1OpenQueueStatus.html">bmqa::OpenQueueStatus</a></code>. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a44c23507ec0aaf46d526d02dee341e09">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a68b18cc9c0eff992a3536c4988c96251"></a><!-- doxytag: member="bmqa::MockSession::configureQueue" ref="a68b18cc9c0eff992a3536c4988c96251" args="(QueueId *queueId, const bmqt::QueueOptions &amp;options=bmqt::QueueOptions(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::MockSession::configureQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DEPRECATED: Use the 'configureQueueSync(<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId...) instead. This method will be marked as <code>BSLS_ANNOTATION_DEPRECATED</code> in future release of libbmq. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#af118dfa2165a17cc22786f84b080fa96">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a4986cbd66587a026565c8663efd62bb2"></a><!-- doxytag: member="bmqa::MockSession::configureQueueSync" ref="a4986cbd66587a026565c8663efd62bb2" args="(const QueueId *queueId, const bmqt::QueueOptions &amp;options, const bsls::TimeInterval &amp;timeout) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbmqa_1_1ConfigureQueueStatus.html">ConfigureQueueStatus</a> bmqa::MockSession::configureQueueSync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configure the queue identified by the specified <code>queueId</code> using the specified <code>options</code> to configure some advanced settings and return a result providing the status and context of the operation. In general, a call to <code>configureQueueSync</code> emits nothing. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a7d090b4869286909fbc78c7da2214e7f">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="ae352999956a9a8a68179a714fe0c3306"></a><!-- doxytag: member="bmqa::MockSession::configureQueueAsync" ref="ae352999956a9a8a68179a714fe0c3306" args="(QueueId *queueId, const bmqt::QueueOptions &amp;options=bmqt::QueueOptions(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::MockSession::configureQueueAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DEPRECATED: Use the <code>configureQueueAsync(...)</code> with callback flavor instead. This method will be marked as <code>BSLS_ANNOTATION_DEPRECATED</code> in future release of libbmq. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a77fd57363c294a6c390503e31f54ec38">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a3845bef0c8ca02fd737fe975815f354f"></a><!-- doxytag: member="bmqa::MockSession::configureQueueAsync" ref="a3845bef0c8ca02fd737fe975815f354f" args="(const QueueId *queueId, const bmqt::QueueOptions &amp;options, const ConfigureQueueCallback &amp;callback, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bmqa::MockSession::configureQueueAsync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1AbstractSession.html#a0a63dcba9d8cabae9bb083865db83c20">ConfigureQueueCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously configure the queue identified by the specified <code>queueId</code> using the specified <code>options</code> to configure some advanced settings. The result of the operation is communicated to the specified <code>callback</code> via a <code><a class="el" href="classbmqa_1_1ConfigureQueueStatus.html">bmqa::ConfigureQueueStatus</a></code>, providing the status and context of the requested operation. In general, a call to <code>configureQueueAsync</code> does not emit a <code><a class="el" href="classbmqa_1_1SessionEvent.html">SessionEvent</a></code>, but rather invokes the <code>callback</code> (if provided) instead when the corresponding <code>emitEvent</code> is called. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a183bd13f3f968d2524c3a890127f2fad">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a8cecfb0853dd4fe41e246fb9905cc95e"></a><!-- doxytag: member="bmqa::MockSession::closeQueue" ref="a8cecfb0853dd4fe41e246fb9905cc95e" args="(QueueId *queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::MockSession::closeQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DEPRECATED: Use the <code>closeQueueSync(<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId...)</code> instead. This method will be marked as <code>BSLS_ANNOTATION_DEPRECATED</code> in future release of libbmq. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a773a86f6ff75cc4dd328ddedd2d7e886">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a1a016fc12d2039ca3efdf01b287714dc"></a><!-- doxytag: member="bmqa::MockSession::closeQueueSync" ref="a1a016fc12d2039ca3efdf01b287714dc" args="(const QueueId *queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbmqa_1_1CloseQueueStatus.html">CloseQueueStatus</a> bmqa::MockSession::closeQueueSync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close the queue identified by the specified <code>queueId</code> using the specified <code>timeout</code>. Populate the optionally specified <code>result</code> with the status and context of the operation and return a value providing the status of the operation. In general, a call to <code>closeQueueSync</code> emits nothing. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a1c8ece4df2266e698dd51af3101abc54">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="ac1b6fe877b8711b489428613a55d7d2c"></a><!-- doxytag: member="bmqa::MockSession::closeQueueAsync" ref="ac1b6fe877b8711b489428613a55d7d2c" args="(QueueId *queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::MockSession::closeQueueAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DEPRECATED: Use the <code>closeQueueAsync(...)</code> with callback flavor instead. This method will be marked as <code>BSLS_ANNOTATION_DEPRECATED</code> in future release of libbmq. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a8b4b33f933be8f5be5b17f508c83c13f">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="acf330edf0bab3cae2b13da59736fd8ef"></a><!-- doxytag: member="bmqa::MockSession::closeQueueAsync" ref="acf330edf0bab3cae2b13da59736fd8ef" args="(const QueueId *queueId, const CloseQueueCallback &amp;callback, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bmqa::MockSession::closeQueueAsync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1AbstractSession.html#a657f8f6d3779ef7b5697be304e8415c6">CloseQueueCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously close the queue identified by the specified <code>queueId</code> using the specified <code>timeout</code>. The result of the operation is communicated to the specified <code>callback</code> via a <code><a class="el" href="classbmqa_1_1CloseQueueStatus.html">bmqa::CloseQueueStatus</a></code>, providing the status and context of the requested operation. In general, a call to <code>closeQueueAsync</code> does not emit a <code><a class="el" href="classbmqa_1_1SessionEvent.html">SessionEvent</a></code>, but rather invokes the <code>callback</code> (if provided) instead when the corresponding <code>emitEvent</code> is called. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a4766c5a33a2714c53ebb147e6298b2f1">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="aabdfafe3f69ab8ae30559f9b39336376"></a><!-- doxytag: member="bmqa::MockSession::nextEvent" ref="aabdfafe3f69ab8ae30559f9b39336376" args="(const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbmqa_1_1Event.html">Event</a> bmqa::MockSession::nextEvent </td>
          <td>(</td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the nextEvent emitted.</p>
<p>NOTE: This method should only be used when the <code><a class="el" href="classbmqa_1_1MockSession.html">MockSession</a></code> has been created in synchronous mode. It is invalid if used in asynchronous mode and your test case is likely to be faulty if used with such a set up. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#ab791e98ffb989c97411966856a4d527b">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="aa9b85b4355f83b4f33e7381f131c5ab4"></a><!-- doxytag: member="bmqa::MockSession::post" ref="aa9b85b4355f83b4f33e7381f131c5ab4" args="(const MessageEvent &amp;messageEvent) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::MockSession::post </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1MessageEvent.html">MessageEvent</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>messageEvent</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Post the specified <code>messageEvent</code>. Return values are defined as per <code><a class="el" href="structbmqt_1_1PostResult.html">bmqt::PostResult</a></code>. In general a call to <code>post</code> emits a <code><a class="el" href="classbmqa_1_1MessageEvent.html">MessageEvent</a></code> of type <code>e_ACK</code> or no response if acks are not requested. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a5b338c949ef2d008e2e491bcc74f9ecd">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="aa0e92d35e2a134a88144aadef4a390b8"></a><!-- doxytag: member="bmqa::MockSession::confirmMessage" ref="aa0e92d35e2a134a88144aadef4a390b8" args="(const Message &amp;message) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::MockSession::confirmMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1Message.html">Message</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>message</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously confirm the receipt of the specified <code>message</code>. This indicates that the application is done processing the message and that the broker can safely discard it from the queue according to the retention policy set up for that queue. Return 0 on success, and a non-zero value otherwise. Note that success implies that SDK has accepted the <code>message</code> and will eventually send confirmation notification to the broker. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#ac0fbce3bb5f93d991063bea9ea3ebb8d">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a0b29178d3c4b2c125289d498d242be11"></a><!-- doxytag: member="bmqa::MockSession::confirmMessage" ref="a0b29178d3c4b2c125289d498d242be11" args="(const MessageConfirmationCookie &amp;cookie) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::MockSession::confirmMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1MessageConfirmationCookie.html">MessageConfirmationCookie</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cookie</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously confirm the receipt of the message with which the specified <code>cookie</code> is associated. This indicates that the application is done processing the message and that the broker can safely discard it from the queue according to the retention policy set up for that queue. Return 0 on success, and a non-zero value otherwise. Note that success implies that SDK has accepted the <code>message</code> and will eventually send confirmation notification to the broker. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#af78c7080723764b041baf5825fab4ed7">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a38634ff51f7ef256616b581086ff657f"></a><!-- doxytag: member="bmqa::MockSession::confirmMessages" ref="a38634ff51f7ef256616b581086ff657f" args="(ConfirmEventBuilder *builder) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::MockSession::confirmMessages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1ConfirmEventBuilder.html">ConfirmEventBuilder</a> *&nbsp;</td>
          <td class="paramname"> <em>builder</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Confirm messages specified by the <code>message</code>, <code>cookie</code> or <code>builder</code>. Return values are defined as per <code><a class="el" href="structbmqt_1_1GenericResult.html">bmqt::GenericResult</a></code>. No event is emitted for calls to <code>confirmMessage</code>. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a8487ac7a95e51c25c6bbacf822786972">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a802d9ad2faa75ea6abdb570c35a18c2e"></a><!-- doxytag: member="bmqa::MockSession::configureMessageDumping" ref="a802d9ad2faa75ea6abdb570c35a18c2e" args="(const bslstl::StringRef &amp;command) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::MockSession::configureMessageDumping </td>
          <td>(</td>
          <td class="paramtype">const bslstl::StringRef &amp;&nbsp;</td>
          <td class="paramname"> <em>command</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configure this session instance to dump messages to the installed logger at <code>ball::Severity::INFO</code> level according to the specified <code>command</code> that should adhere to the following pattern: </p>
<div class="fragment"><pre class="fragment">           IN|OUT ON|OFF|100|10s
</pre></div><p> where each token has a specific meaning: </p>
<ul>
<li>
<b>IN</b> : incoming (<code>PUSH</code> and <code>ACK</code>) events  </li>
<li>
<b>OUT</b> : outgoing (<code>PUT</code> and <code>CONFIRM</code>) events  </li>
<li>
<b>ON</b> : turn on message dumping until explicitly turned off  </li>
<li>
<b>OFF</b> : turn off message dumping  </li>
<li>
<b>100</b> : turn on message dumping for the next 100 messages  </li>
<li>
<b>10s</b> : turn on message dumping for the next 10 seconds  </li>
</ul>
<p>Note that above, <code>100</code> and <code>10</code> numerical values are for just for illustration purposes, and application can choose an appropriate value for them. Also note that pattern is case-insensitive. Return zero if <code>command</code> is valid and message dumping has been configured, non-zero value otherwise. The behavior is undefined unless the session has been started. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a777888d11903cac52eb14915ad29e4be">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="ad0c3ac8a0893946607207c68f8bfa856"></a><!-- doxytag: member="bmqa::MockSession::setFailureCallback" ref="ad0c3ac8a0893946607207c68f8bfa856" args="(const FailureCb &amp;failureCb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bmqa::MockSession::setFailureCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1MockSession.html#a9ec7f395b2a5079ff32170751941627d">FailureCb</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>failureCb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the failure callback of to be the specified <code>failureCb</code>. This callback is invoked whenever an expectation set by the test driver is not met. </p>

</div>
</div>
<a class="anchor" id="a2cf3158b9ba9f7a07960f3429639f170"></a><!-- doxytag: member="bmqa::MockSession::popPostedEvent" ref="a2cf3158b9ba9f7a07960f3429639f170" args="(bmqa::MessageEvent *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bmqa::MockSession::popPostedEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1MessageEvent.html">bmqa::MessageEvent</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>event</code> the next posted event on this session, if any, and return true; leave <code>event</code> unchanged and return false otherwise. </p>

</div>
</div>
<a class="anchor" id="a87a7155dcd25e4d7a56aa839274ff26d"></a><!-- doxytag: member="bmqa::MockSession::unconfirmedMessages" ref="a87a7155dcd25e4d7a56aa839274ff26d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t bmqa::MockSession::unconfirmedMessages </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the number of unconfirmed messages. This corresponds to the number of push messages enqueued to the session object but not yet confirmed by the application. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bmqa__mocksession_8h_source.html">bmqa_mocksession.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Jun 15 2023 11:58:51 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
