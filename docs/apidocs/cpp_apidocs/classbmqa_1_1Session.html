<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Class bmqa::Session</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="bdedox.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bmqa.html" target="_blank">bmqa</a> | <a class="qindex" href="group__bmqpi.html" target="_blank">bmqpi</a> | <a class="qindex" href="group__bmqt.html" target="_blank">bmqt</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="components.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebmqa.html">bmqa</a>      </li>
      <li><a class="el" href="classbmqa_1_1Session.html">bmqa::Session</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bmqa::Session Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bmqa::Session" --><!-- doxytag: inherits="bmqa::AbstractSession" -->
<p><code>#include &lt;<a class="el" href="bmqa__session_8h_source.html">bmqa_session.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for bmqa::Session:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbmqa_1_1Session.png" usemap="#bmqa::Session_map" alt=""/>
  <map id="bmqa::Session_map" name="bmqa::Session_map">
<area href="classbmqa_1_1AbstractSession.html" alt="bmqa::AbstractSession" shape="rect" coords="0,0,138,24"/>
</map>
</div>

<p><a href="classbmqa_1_1Session-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classbmqa_1_1AbstractSession.html#a75e7237336027136889801133334b72d">AbstractSession::OpenQueueCallback</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a4287dbcc814771d709b3d48094641519">OpenQueueCallback</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classbmqa_1_1AbstractSession.html#a0a63dcba9d8cabae9bb083865db83c20">AbstractSession::ConfigureQueueCallback</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#aade4d05e446e2bc2a93f5821d8d508e7">ConfigureQueueCallback</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classbmqa_1_1AbstractSession.html#a657f8f6d3779ef7b5697be304e8415c6">AbstractSession::CloseQueueCallback</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#af8b2998c51e4a9f8d83ecf9a9751a8e7">CloseQueueCallback</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a0615be4faa467a44dafe5a18d8fca059">Session</a> (const <a class="el" href="classbmqt_1_1SessionOptions.html">bmqt::SessionOptions</a> &amp;options=<a class="el" href="classbmqt_1_1SessionOptions.html">bmqt::SessionOptions</a>(), bslma::Allocator *allocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#aed0cd2157708c7b75e636b6c0c4938e1">Session</a> (bslma::ManagedPtr&lt; <a class="el" href="classbmqa_1_1SessionEventHandler.html">SessionEventHandler</a> &gt; eventHandler, const <a class="el" href="classbmqt_1_1SessionOptions.html">bmqt::SessionOptions</a> &amp;options=<a class="el" href="classbmqt_1_1SessionOptions.html">bmqt::SessionOptions</a>(), bslma::Allocator *allocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#ade0a578bd916da39a806755f6be621b0">~Session</a> () BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a5f8aafcc526a95123bab44f321ee23b6">start</a> (const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a8f0d219488c2334aee8173f5239ff9c6">startAsync</a> (const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a8ce13e884cd76e2f60738d8fc0c68722">stop</a> () BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a8cb915eee3acc7668db74d2c31e96f6c">stopAsync</a> () BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#ae3f12b32febe243a70a74378c22037df">finalizeStop</a> () BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbmqa_1_1MessageEventBuilder.html">MessageEventBuilder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a9fe958496f32b083e4ae3fd4ae27bda4">createMessageEventBuilder</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a898eeb0dd7a3407bb1a2788ae8ecb7ff">loadMessageEventBuilder</a> (<a class="el" href="classbmqa_1_1MessageEventBuilder.html">MessageEventBuilder</a> *builder) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#ae1308efd8c03f795c33bd4c8a48790c4">loadConfirmEventBuilder</a> (<a class="el" href="classbmqa_1_1ConfirmEventBuilder.html">ConfirmEventBuilder</a> *builder) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#af92a8ab7524dc908ece5da97744a22f3">loadMessageProperties</a> (<a class="el" href="classbmqa_1_1MessageProperties.html">MessageProperties</a> *buffer) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#ab175af39f8ffedcc7f22ab5d68663c4a">getQueueId</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;uri) const BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a81ba9d0450e48ef9a69914ab0398eb30">getQueueId</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1CorrelationId.html">bmqt::CorrelationId</a> &amp;correlationId) const BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a25059f75562d96250889ea230cae2bfd">openQueue</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;uri, bsls::Types::Uint64 flags, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options=<a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbmqa_1_1OpenQueueStatus.html">OpenQueueStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a7b62b74a9a4d4dd3e24765d6e54e8c9a">openQueueSync</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;uri, bsls::Types::Uint64 flags, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options=<a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a7a40d42652189827618bd2b761d192d2">openQueue</a> (const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> &amp;queueId, const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;uri, bsls::Types::Uint64 flags, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options=<a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a97d407ebfe405a0baa9a8e3a14d98759">openQueueAsync</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;uri, bsls::Types::Uint64 flags, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options=<a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a2b1d044be01c38d033047e829763fb0f">openQueueAsync</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;uri, bsls::Types::Uint64 flags, const <a class="el" href="classbmqa_1_1AbstractSession.html#a75e7237336027136889801133334b72d">OpenQueueCallback</a> &amp;callback, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options=<a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a537def25e7ee779b63a4fca8bfcefbcc">configureQueue</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbmqa_1_1ConfigureQueueStatus.html">ConfigureQueueStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#af10950d3245e8acf6a4fc4403c7f433a">configureQueueSync</a> (const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a713131557d6b53c042b0fa798eb5991e">configureQueueAsync</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#acef278ef21a184e84fc0f40fc48630db">configureQueueAsync</a> (const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;options, const <a class="el" href="classbmqa_1_1AbstractSession.html#a0a63dcba9d8cabae9bb083865db83c20">ConfigureQueueCallback</a> &amp;callback, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a109e6bef1a92915e7a9787c1ca719f5e">closeQueue</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbmqa_1_1CloseQueueStatus.html">CloseQueueStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#aa02a0adb8aa506268903a6e9b14ee11a">closeQueueSync</a> (const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a31e93bd1da54b5a3f0132d379b44e2d1">closeQueue</a> (const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> &amp;queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#ad1ff2484bb7e6a9edb7d4d8e72dee8f4">closeQueueAsync</a> (<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a61942408f7dddfa79a8efb7cf8f0bfe8">closeQueueAsync</a> (const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId, const <a class="el" href="classbmqa_1_1AbstractSession.html#a657f8f6d3779ef7b5697be304e8415c6">CloseQueueCallback</a> &amp;callback, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a5d4844e7c2010271c5845c8fee97f2a1">closeQueueAsync</a> (const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> &amp;queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbmqa_1_1Event.html">Event</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a865d173f667d4901324c2ef58e1ec8ba">nextEvent</a> (const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a6e1d0349415ed25dafc141ad6d68c7e7">post</a> (const <a class="el" href="classbmqa_1_1MessageEvent.html">MessageEvent</a> &amp;event) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a0b977f8da81201169727727c8bc86c7c">confirmMessage</a> (const <a class="el" href="classbmqa_1_1Message.html">Message</a> &amp;message) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a165f5b7d76359fb497e57577fe672cec">confirmMessage</a> (const <a class="el" href="classbmqa_1_1MessageConfirmationCookie.html">MessageConfirmationCookie</a> &amp;cookie) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#ad956f64b183e04e20c23ad7b8846eb28">confirmMessages</a> (<a class="el" href="classbmqa_1_1ConfirmEventBuilder.html">ConfirmEventBuilder</a> *builder) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a0600029292f5b33d5b22f9a7afab5c72">configureMessageDumping</a> (const bslstl::StringRef &amp;command) BSLS_KEYWORD_OVERRIDE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbmqa_1_1Session.html#a73f8ee8692ee8f1dac28889ab7c7484f">impl</a> ()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A session with a BlazingMQ broker.</p>
<p>See <a class="el" href="group__bmqa__session.html">Component bmqa_session</a> </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a4287dbcc814771d709b3d48094641519"></a><!-- doxytag: member="bmqa::Session::OpenQueueCallback" ref="a4287dbcc814771d709b3d48094641519" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classbmqa_1_1AbstractSession.html#a75e7237336027136889801133334b72d">AbstractSession::OpenQueueCallback</a> <a class="el" href="classbmqa_1_1Session.html#a4287dbcc814771d709b3d48094641519">bmqa::Session::OpenQueueCallback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoked as a response to an asynchronous open queue operation, <code>OpenQueueCallback</code> is an alias for a callback function object (functor) that takes as an argument the specified <code>result</code>, providing the result and context of the requested operation. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a75e7237336027136889801133334b72d">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="aade4d05e446e2bc2a93f5821d8d508e7"></a><!-- doxytag: member="bmqa::Session::ConfigureQueueCallback" ref="aade4d05e446e2bc2a93f5821d8d508e7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classbmqa_1_1AbstractSession.html#a0a63dcba9d8cabae9bb083865db83c20">AbstractSession::ConfigureQueueCallback</a> <a class="el" href="classbmqa_1_1Session.html#aade4d05e446e2bc2a93f5821d8d508e7">bmqa::Session::ConfigureQueueCallback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoked as a response to an asynchronous configure queue operation, <code>ConfigureQueueCallback</code> is an alias for a callback function object (functor) that takes as an argument the specified <code>result</code>, providing the result and context of the requested operation. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a0a63dcba9d8cabae9bb083865db83c20">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="af8b2998c51e4a9f8d83ecf9a9751a8e7"></a><!-- doxytag: member="bmqa::Session::CloseQueueCallback" ref="af8b2998c51e4a9f8d83ecf9a9751a8e7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classbmqa_1_1AbstractSession.html#a657f8f6d3779ef7b5697be304e8415c6">AbstractSession::CloseQueueCallback</a> <a class="el" href="classbmqa_1_1Session.html#af8b2998c51e4a9f8d83ecf9a9751a8e7">bmqa::Session::CloseQueueCallback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoked as a response to an asynchronous close queue operation, <code>CloseQueueCallback</code> is an alias for a callback function object (functor) that takes as an argument the specified <code>result</code>, providing the result and context of the requested operation. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a657f8f6d3779ef7b5697be304e8415c6">bmqa::AbstractSession</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0615be4faa467a44dafe5a18d8fca059"></a><!-- doxytag: member="bmqa::Session::Session" ref="a0615be4faa467a44dafe5a18d8fca059" args="(const bmqt::SessionOptions &amp;options=bmqt::SessionOptions(), bslma::Allocator *allocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bmqa::Session::Session </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1SessionOptions.html">bmqt::SessionOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1SessionOptions.html">bmqt::SessionOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new <code><a class="el" href="classbmqa_1_1Session.html">Session</a></code> in <em>synchronous</em> mode using the optionally specified <code>options</code>. In such mode, events have to be fetched by the application using the <code><a class="el" href="classbmqa_1_1Session.html#a865d173f667d4901324c2ef58e1ec8ba">nextEvent()</a></code> method. Optionally specify an <code>allocator</code> used to supply memory. If <code>allocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="aed0cd2157708c7b75e636b6c0c4938e1"></a><!-- doxytag: member="bmqa::Session::Session" ref="aed0cd2157708c7b75e636b6c0c4938e1" args="(bslma::ManagedPtr&lt; SessionEventHandler &gt; eventHandler, const bmqt::SessionOptions &amp;options=bmqt::SessionOptions(), bslma::Allocator *allocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bmqa::Session::Session </td>
          <td>(</td>
          <td class="paramtype">bslma::ManagedPtr&lt; <a class="el" href="classbmqa_1_1SessionEventHandler.html">SessionEventHandler</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>eventHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1SessionOptions.html">bmqt::SessionOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1SessionOptions.html">bmqt::SessionOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code><a class="el" href="classbmqa_1_1Session.html">Session</a></code> in <em>asynchronous</em> mode using the specified <code>eventHandler</code> as callback for event processing and the optionally specified <code>options</code>. Optionally specify an <code>allocator</code> used to supply memory. If the optionally specified <code>allocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="ade0a578bd916da39a806755f6be621b0"></a><!-- doxytag: member="bmqa::Session::~Session" ref="ade0a578bd916da39a806755f6be621b0" args="() BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bmqa::Session::~Session </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stop the <code><a class="el" href="classbmqa_1_1Session.html">Session</a></code> and destroy this object. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5f8aafcc526a95123bab44f321ee23b6"></a><!-- doxytag: member="bmqa::Session::start" ref="a5f8aafcc526a95123bab44f321ee23b6" args="(const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::Session::start </td>
          <td>(</td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connect to the BlazingMQ broker and start the message processing for this <code><a class="el" href="classbmqa_1_1Session.html">Session</a></code>. This method blocks until either the <code><a class="el" href="classbmqa_1_1Session.html">Session</a></code> is connected to the broker, fails to connect, or the operation times out. If the optionally specified <code>timeout</code> is not populated, use the one defined in the session options. Return 0 on success, or a non-zero value corresponding to the <code><a class="el" href="structbmqt_1_1GenericResult.html#a637624d4e7f6e21b9411b630769286cc">bmqt::GenericResult::Enum</a></code> enum values otherwise. The behavior is undefined if this method is called on an already started <code><a class="el" href="classbmqa_1_1Session.html">Session</a></code>. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a88337ae19f335352f32f98818d2d82e9">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a8f0d219488c2334aee8173f5239ff9c6"></a><!-- doxytag: member="bmqa::Session::startAsync" ref="a8f0d219488c2334aee8173f5239ff9c6" args="(const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::Session::startAsync </td>
          <td>(</td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connect to the BlazingMQ broker and start the message processing for this <code><a class="el" href="classbmqa_1_1Session.html">Session</a></code>. This method returns without blocking. The result of the operation is communicated with a session event. If the optionally specified <code>timeout</code> is not populated, use the one defined in the session options. Return 0 on success (this doesn't imply the session is connected !), or a non-zero value corresponding to the <code><a class="el" href="structbmqt_1_1GenericResult.html#a637624d4e7f6e21b9411b630769286cc">bmqt::GenericResult::Enum</a></code> enum values otherwise. The behavior is undefined if this method is called on an already started <code><a class="el" href="classbmqa_1_1Session.html">Session</a></code>. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a42ba613e230863b89cd8f31413b9afc0">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a8ce13e884cd76e2f60738d8fc0c68722"></a><!-- doxytag: member="bmqa::Session::stop" ref="a8ce13e884cd76e2f60738d8fc0c68722" args="() BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bmqa::Session::stop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gracefully disconnect from the BlazingMQ broker and stop the operation of this <code><a class="el" href="classbmqa_1_1Session.html">Session</a></code>. This method blocks waiting for all already invoked event handlers to exit and all session-related operations to be finished. No other method but <code><a class="el" href="classbmqa_1_1Session.html#a5f8aafcc526a95123bab44f321ee23b6">start()</a></code> may be used after this method returns. This method must <em>NOT</em> be called if the session is in synchronous mode (i.e., not using the EventHandler), <code><a class="el" href="classbmqa_1_1Session.html#a8cb915eee3acc7668db74d2c31e96f6c">stopAsync()</a></code> should be called in this case. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a39b54dd9aff5fb0165dfb382641f7606">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a8cb915eee3acc7668db74d2c31e96f6c"></a><!-- doxytag: member="bmqa::Session::stopAsync" ref="a8cb915eee3acc7668db74d2c31e96f6c" args="() BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bmqa::Session::stopAsync </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disconnect from the BlazingMQ broker and stop the operation of this <code><a class="el" href="classbmqa_1_1Session.html">Session</a></code>. This method returns without blocking and neither enforce nor waits for any already started session-related operation to be finished. No method may be used after this method returns. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a6431f6eee936f03b40fa33385832824a">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="ae3f12b32febe243a70a74378c22037df"></a><!-- doxytag: member="bmqa::Session::finalizeStop" ref="ae3f12b32febe243a70a74378c22037df" args="() BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bmqa::Session::finalizeStop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>**DEPRECATED**</p>
<p>This method is only to be used if the session is in synchronous mode (i.e., not using the EventHandler): it must be called once all threads getting events with <code><a class="el" href="classbmqa_1_1Session.html#a865d173f667d4901324c2ef58e1ec8ba">nextEvent()</a></code> have been joined. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a5a790a8e3881e37740023204ea5f71fa">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a9fe958496f32b083e4ae3fd4ae27bda4"></a><!-- doxytag: member="bmqa::Session::createMessageEventBuilder" ref="a9fe958496f32b083e4ae3fd4ae27bda4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbmqa_1_1MessageEventBuilder.html">MessageEventBuilder</a> bmqa::Session::createMessageEventBuilder </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <a class="el" href="classbmqa_1_1MessageEventBuilder.html">MessageEventBuilder</a> that can be used to build message event for posting on this session. The behavior is undefined unless the session has been successfully started. Note that lifetime of the returned object is bound by the lifetime of this session instance (i.e., returned instance cannot outlive this session instance). Also note that the <code><a class="el" href="classbmqa_1_1MessageEventBuilder.html">MessageEventBuilder</a></code> objects are pooled, so this operation is cheap, and <code><a class="el" href="classbmqa_1_1MessageEventBuilder.html">MessageEventBuilder</a></code> can be obtained on demand and kept on the stack.</p>
<p>DEPRECATED: Use the 'loadMessageEventBuilder instead. This method will be marked as <code>BSLS_ANNOTATION_DEPRECATED</code> in future release of libbmq. </p>

</div>
</div>
<a class="anchor" id="a898eeb0dd7a3407bb1a2788ae8ecb7ff"></a><!-- doxytag: member="bmqa::Session::loadMessageEventBuilder" ref="a898eeb0dd7a3407bb1a2788ae8ecb7ff" args="(MessageEventBuilder *builder) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bmqa::Session::loadMessageEventBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1MessageEventBuilder.html">MessageEventBuilder</a> *&nbsp;</td>
          <td class="paramname"> <em>builder</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>builder</code> an instance of <code><a class="el" href="classbmqa_1_1MessageEventBuilder.html">bmqa::MessageEventBuilder</a></code> that can be used to build message event for posting on this session. The behavior is undefined unless the session has been successfully started and <code>builder</code> is non-null. Note that lifetime of the loaded object is bound by the lifetime of this session instance (i.e., loaded instance cannot outlive this session instance). Also note that the <code><a class="el" href="classbmqa_1_1MessageEventBuilder.html">MessageEventBuilder</a></code> objects are pooled, so this operation is cheap, and <code><a class="el" href="classbmqa_1_1MessageEventBuilder.html">MessageEventBuilder</a></code> can be obtained on demand and kept on the stack. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#acee2b8777224bfb88f59904551c69755">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="ae1308efd8c03f795c33bd4c8a48790c4"></a><!-- doxytag: member="bmqa::Session::loadConfirmEventBuilder" ref="ae1308efd8c03f795c33bd4c8a48790c4" args="(ConfirmEventBuilder *builder) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bmqa::Session::loadConfirmEventBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1ConfirmEventBuilder.html">ConfirmEventBuilder</a> *&nbsp;</td>
          <td class="paramname"> <em>builder</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>builder</code> an instance of <code><a class="el" href="classbmqa_1_1ConfirmEventBuilder.html">bmqa::ConfirmEventBuilder</a></code> that can be used to build a batch of CONFIRM messages for sending to the broker. The behavior is undefined unless the session has been successfully started and <code>builder</code> is non-null. Note that the lifetime of the loaded object is bound by the lifetime of this session instance (i.e., loaded instance cannot outlive this session instance). </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a0662d3695901ef024ea773abf8a50482">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="af92a8ab7524dc908ece5da97744a22f3"></a><!-- doxytag: member="bmqa::Session::loadMessageProperties" ref="af92a8ab7524dc908ece5da97744a22f3" args="(MessageProperties *buffer) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bmqa::Session::loadMessageProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1MessageProperties.html">MessageProperties</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>buffer</code> an instance of <code><a class="el" href="classbmqa_1_1MessageProperties.html">MessageProperties</a></code> that can be used to specify and associate properties while building a <code><a class="el" href="classbmqa_1_1Message.html">bmqa::Message</a></code>. The behavior is undefined unless the session has been successfully started and <code>buffer</code> is non-null. Note that lifetime of the loaded object is bound by the lifetime of this session instance (i.e., loaded instance cannot outlive this session instance). </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#ab5b6459aa7eb97c5a058ef9a8f1f6409">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="ab175af39f8ffedcc7f22ab5d68663c4a"></a><!-- doxytag: member="bmqa::Session::getQueueId" ref="ab175af39f8ffedcc7f22ab5d68663c4a" args="(QueueId *queueId, const bmqt::Uri &amp;uri) const BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::Session::getQueueId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uri</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load in the specified <code>queueId</code> the queue corresponding to the specified <code>uri</code> and return 0 if such a queue was found, or leave <code>queueId</code> untouched and return a non-zero value if no queue corresponding to <code>uri</code> is currently open. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a897bf80e972bd2d8d356c89ac7960431">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a81ba9d0450e48ef9a69914ab0398eb30"></a><!-- doxytag: member="bmqa::Session::getQueueId" ref="a81ba9d0450e48ef9a69914ab0398eb30" args="(QueueId *queueId, const bmqt::CorrelationId &amp;correlationId) const BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::Session::getQueueId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1CorrelationId.html">bmqt::CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load in the specified <code>queueId</code> the queue corresponding to the specified <code>correlationId</code> and return 0 if such a queue was found, or leave <code>queueId</code> untouched and return a non-zero value if no queue corresponding to <code>correlationId</code> is currently open. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#af07daee8b4e090189aa719c896e1e14f">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a25059f75562d96250889ea230cae2bfd"></a><!-- doxytag: member="bmqa::Session::openQueue" ref="a25059f75562d96250889ea230cae2bfd" args="(QueueId *queueId, const bmqt::Uri &amp;uri, bsls::Types::Uint64 flags, const bmqt::QueueOptions &amp;options=bmqt::QueueOptions(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::Session::openQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsls::Types::Uint64&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DEPRECATED: Use the <code>openQueueSync(<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId...)</code> instead. This method will be marked as <code>BSLS_ANNOTATION_DEPRECATED</code> in future release of libbmq. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a24e5640b6226a6ff8d43a0d4015f0b16">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a7b62b74a9a4d4dd3e24765d6e54e8c9a"></a><!-- doxytag: member="bmqa::Session::openQueueSync" ref="a7b62b74a9a4d4dd3e24765d6e54e8c9a" args="(QueueId *queueId, const bmqt::Uri &amp;uri, bsls::Types::Uint64 flags, const bmqt::QueueOptions &amp;options=bmqt::QueueOptions(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbmqa_1_1OpenQueueStatus.html">OpenQueueStatus</a> bmqa::Session::openQueueSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsls::Types::Uint64&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Open the queue having the specified <code>uri</code> with the specified <code>flags</code> (a combination of the values defined in <code><a class="el" href="structbmqt_1_1QueueFlags.html#a7f1a1e2ba9084565388e19bc1921a4f2">bmqt::QueueFlags::Enum</a></code>), using the specified <code>queueId</code> to correlate events related to that queue. The object <code>queueId</code> referring to is modified, so the <code>queueId</code> represents the actual queue uri, flags and options. Return a result providing the status and context of the operation. Use the optionally specified <code>options</code> to configure some advanced settings. Note that this operation fails if <code>queueId</code> is non-unique. If the optionally specified <code>timeout</code> is not populated, use the one defined in the session options. This operation will block until either success, failure, or timing out happens.</p>
<p>THREAD: Note that calling this method from the event processing thread(s) (i.e., from the EventHandler callback, if provided) <em>WILL</em> lead to a <em>DEADLOCK</em>. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a7facfe47066415f6977ef6b78547ca43">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a7a40d42652189827618bd2b761d192d2"></a><!-- doxytag: member="bmqa::Session::openQueue" ref="a7a40d42652189827618bd2b761d192d2" args="(const QueueId &amp;queueId, const bmqt::Uri &amp;uri, bsls::Types::Uint64 flags, const bmqt::QueueOptions &amp;options=bmqt::QueueOptions(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int bmqa::Session::openQueue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsls::Types::Uint64&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DEPRECATED: Use the <code>openQueue(<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId...)</code> instead. This method will be marked as <code>BSLS_ANNOTATION_DEPRECATED</code> in future release of libbmq. </p>

</div>
</div>
<a class="anchor" id="a97d407ebfe405a0baa9a8e3a14d98759"></a><!-- doxytag: member="bmqa::Session::openQueueAsync" ref="a97d407ebfe405a0baa9a8e3a14d98759" args="(QueueId *queueId, const bmqt::Uri &amp;uri, bsls::Types::Uint64 flags, const bmqt::QueueOptions &amp;options=bmqt::QueueOptions(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::Session::openQueueAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsls::Types::Uint64&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DEPRECATED: Use the <code>openQueueAsync(...)</code> with callback flavor instead. This method will be marked as <code>BSLS_ANNOTATION_DEPRECATED</code> in future release of libbmq. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a9c526171c5bf03bd1b3ea993bdc7fabc">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a2b1d044be01c38d033047e829763fb0f"></a><!-- doxytag: member="bmqa::Session::openQueueAsync" ref="a2b1d044be01c38d033047e829763fb0f" args="(QueueId *queueId, const bmqt::Uri &amp;uri, bsls::Types::Uint64 flags, const OpenQueueCallback &amp;callback, const bmqt::QueueOptions &amp;options=bmqt::QueueOptions(), const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bmqa::Session::openQueueAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1Uri.html">bmqt::Uri</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsls::Types::Uint64&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1AbstractSession.html#a75e7237336027136889801133334b72d">OpenQueueCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously open the queue having the specified <code>uri</code> with the specified <code>flags</code> (a combination of the values defined in <code><a class="el" href="structbmqt_1_1QueueFlags.html#a7f1a1e2ba9084565388e19bc1921a4f2">bmqt::QueueFlags::Enum</a></code>), using the specified <code>queueId</code> to correlate events related to that queue and the optionally specified <code>options</code> to configure some advanced settings. The object <code>queueId</code> referring to is modified, so the <code>queueId</code> represents the actual queue uri, flags and options. The result of the operation is communicated to the specified <code>callback</code> via a <code><a class="el" href="classbmqa_1_1OpenQueueStatus.html">bmqa::OpenQueueStatus</a></code>, providing the status and context of the requested operation. Note that this operation fails if <code>queueId</code> is non-unique. If the optionally specified <code>timeout</code> is not populated, use the one defined in the session options.</p>
<p>THREAD: The <code>callback</code> will <em>ALWAYS</em> be invoked from the EventHandler thread(s) (or if a <a class="el" href="classbmqa_1_1SessionEventHandler.html">SessionEventHandler</a> was not specified, from the thread invoking <code>nextEvent</code>). </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a44c23507ec0aaf46d526d02dee341e09">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a537def25e7ee779b63a4fca8bfcefbcc"></a><!-- doxytag: member="bmqa::Session::configureQueue" ref="a537def25e7ee779b63a4fca8bfcefbcc" args="(QueueId *queueId, const bmqt::QueueOptions &amp;options, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::Session::configureQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DEPRECATED: Use the 'configureQueueSync(<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId...) instead. This method will be marked as <code>BSLS_ANNOTATION_DEPRECATED</code> in future release of libbmq. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#af118dfa2165a17cc22786f84b080fa96">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="af10950d3245e8acf6a4fc4403c7f433a"></a><!-- doxytag: member="bmqa::Session::configureQueueSync" ref="af10950d3245e8acf6a4fc4403c7f433a" args="(const QueueId *queueId, const bmqt::QueueOptions &amp;options, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbmqa_1_1ConfigureQueueStatus.html">ConfigureQueueStatus</a> bmqa::Session::configureQueueSync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configure the queue identified by the specified <code>queueId</code> using the specified <code>options</code> and return a result providing the status and context of the operation. If the optionally specified <code>timeout</code> is not populated, use the one defined in the session options. This operation returns error if there is a pending configure for the same queue. This operation will block until either success, failure, or timing out happens.</p>
<p>Note that the following <code><a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a></code> fields cannot be reconfigured after the queue has been opened:</p>
<ul>
<li>suspendsOnBadHostHealth Attempts to reconfigure these fields will yield an <code>e_NOT_SUPPORTED</code> error code.</li>
</ul>
<p>THREAD: Note that calling this method from the event processing thread(s) (i.e., from the EventHandler callback, if provided) <em>WILL</em> lead to a <em>DEADLOCK</em>. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a7d090b4869286909fbc78c7da2214e7f">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a713131557d6b53c042b0fa798eb5991e"></a><!-- doxytag: member="bmqa::Session::configureQueueAsync" ref="a713131557d6b53c042b0fa798eb5991e" args="(QueueId *queueId, const bmqt::QueueOptions &amp;options, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::Session::configureQueueAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DEPRECATED: Use the <code>configureQueueAsync(...)</code> with callback flavor instead. This method will be marked as <code>BSLS_ANNOTATION_DEPRECATED</code> in future release of libbmq. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a77fd57363c294a6c390503e31f54ec38">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="acef278ef21a184e84fc0f40fc48630db"></a><!-- doxytag: member="bmqa::Session::configureQueueAsync" ref="acef278ef21a184e84fc0f40fc48630db" args="(const QueueId *queueId, const bmqt::QueueOptions &amp;options, const ConfigureQueueCallback &amp;callback, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bmqa::Session::configureQueueAsync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1AbstractSession.html#a0a63dcba9d8cabae9bb083865db83c20">ConfigureQueueCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously configure the queue identified by the specified <code>queueId</code> using the specified <code>options</code> to configure some advanced settings. The result of the operation is communicated to the specified <code>callback</code> via a <code><a class="el" href="classbmqa_1_1ConfigureQueueStatus.html">bmqa::ConfigureQueueStatus</a></code>, providing the status and context of the requested operation. If the optionally specified <code>timeout</code> is not populated, use the one defined in the session options.</p>
<p>Note that the following <code><a class="el" href="classbmqt_1_1QueueOptions.html">bmqt::QueueOptions</a></code> fields cannot be reconfigured after the queue has been opened:</p>
<ul>
<li>suspendsOnBadHostHealth Attempts to reconfigure these fields will yield an <code>e_NOT_SUPPORTED</code> error code.</li>
</ul>
<p>THREAD: The <code>callback</code> will <em>ALWAYS</em> be invoked from the EventHandler thread(s) (or if a <a class="el" href="classbmqa_1_1SessionEventHandler.html">SessionEventHandler</a> was not specified, from the thread invoking <code>nextEvent</code>). </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a183bd13f3f968d2524c3a890127f2fad">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a109e6bef1a92915e7a9787c1ca719f5e"></a><!-- doxytag: member="bmqa::Session::closeQueue" ref="a109e6bef1a92915e7a9787c1ca719f5e" args="(QueueId *queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::Session::closeQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DEPRECATED: Use the 'closeQueueSync(<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId...) instead. This method will be marked as <code>BSLS_ANNOTATION_DEPRECATED</code> in future release of libbmq. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a773a86f6ff75cc4dd328ddedd2d7e886">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="aa02a0adb8aa506268903a6e9b14ee11a"></a><!-- doxytag: member="bmqa::Session::closeQueueSync" ref="aa02a0adb8aa506268903a6e9b14ee11a" args="(const QueueId *queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbmqa_1_1CloseQueueStatus.html">CloseQueueStatus</a> bmqa::Session::closeQueueSync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close the queue identified by the specified <code>queueId</code> and return a result providing the status and context of the operation. If the optionally specified <code>timeout</code> is not populated, use the one defined in the session options. Any outstanding configureQueue request for this <code>queueId</code> will be canceled. This operation will block until either success, failure, or timing out happens. Once this method returns, there is guarantee that no more messages and events for this <code>queueId</code> will be received. Note that successful processing of this request in the broker closes this session's view of the queue; the underlying queue may not be deleted in the broker. When this method returns, the correlationId associated to the queue is cleared.</p>
<p>THREAD: Note that calling this method from the event processing thread(s) (i.e., from the EventHandler callback, if provided) <em>WILL</em> lead to a <em>DEADLOCK</em>. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a1c8ece4df2266e698dd51af3101abc54">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a31e93bd1da54b5a3f0132d379b44e2d1"></a><!-- doxytag: member="bmqa::Session::closeQueue" ref="a31e93bd1da54b5a3f0132d379b44e2d1" args="(const QueueId &amp;queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int bmqa::Session::closeQueue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DEPRECATED: Use the 'closeQueue(<a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *queueId...) instead. This method will be marked as <code>BSLS_ANNOTATION_DEPRECATED</code> in future release of libbmq. </p>

</div>
</div>
<a class="anchor" id="ad1ff2484bb7e6a9edb7d4d8e72dee8f4"></a><!-- doxytag: member="bmqa::Session::closeQueueAsync" ref="ad1ff2484bb7e6a9edb7d4d8e72dee8f4" args="(QueueId *queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::Session::closeQueueAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DEPRECATED: Use the <code>closeQueueAsync(...)</code> with callback flavor instead. This method will be marked as <code>BSLS_ANNOTATION_DEPRECATED</code> in future release of libbmq. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a8b4b33f933be8f5be5b17f508c83c13f">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a61942408f7dddfa79a8efb7cf8f0bfe8"></a><!-- doxytag: member="bmqa::Session::closeQueueAsync" ref="a61942408f7dddfa79a8efb7cf8f0bfe8" args="(const QueueId *queueId, const CloseQueueCallback &amp;callback, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bmqa::Session::closeQueueAsync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> *&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1AbstractSession.html#a657f8f6d3779ef7b5697be304e8415c6">CloseQueueCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously close the queue identified by the specified <code>queueId</code>. Any outstanding configureQueue requests will be canceled. The result of the operation is communicated to the specified <code>callback</code> via a <code><a class="el" href="classbmqa_1_1CloseQueueStatus.html">bmqa::CloseQueueStatus</a></code>, providing the status and context of the operation. If the optionally specified <code>timeout</code> is not populated, use the one defined in the session options. Note that successful processing of this request in the broker closes this session's view of the queue; the underlying queue may not be deleted in the broker. The correlationId associated to the queue remains valid until the <code><a class="el" href="classbmqa_1_1CloseQueueStatus.html">bmqa::CloseQueueStatus</a></code> result has been received and processed by the <code>callback</code>, after which it will be cleared and no more messages and events for this <code>queueId</code> will be received.</p>
<p>THREAD: The <code>callback</code> will <em>ALWAYS</em> be invoked from the EventHandler thread(s) (or if a <a class="el" href="classbmqa_1_1SessionEventHandler.html">SessionEventHandler</a> was not specified, from the thread invoking <code>nextEvent</code>). </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a4766c5a33a2714c53ebb147e6298b2f1">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a5d4844e7c2010271c5845c8fee97f2a1"></a><!-- doxytag: member="bmqa::Session::closeQueueAsync" ref="a5d4844e7c2010271c5845c8fee97f2a1" args="(const QueueId &amp;queueId, const bsls::TimeInterval &amp;timeout=bsls::TimeInterval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int bmqa::Session::closeQueueAsync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1QueueId.html">QueueId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DEPRECATED: Use the <code>closeQueueAsync(...)</code> with callback flavor instead. This method will be marked as <code>BSLS_ANNOTATION_DEPRECATED</code> in future release of libbmq. </p>

</div>
</div>
<a class="anchor" id="a865d173f667d4901324c2ef58e1ec8ba"></a><!-- doxytag: member="bmqa::Session::nextEvent" ref="a865d173f667d4901324c2ef58e1ec8ba" args="(const bsls::TimeInterval &amp;timeout=bsls::TimeInterval()) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbmqa_1_1Event.html">Event</a> bmqa::Session::nextEvent </td>
          <td>(</td>
          <td class="paramtype">const bsls::TimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>bsls::TimeInterval()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the next available event received for this session. If there is no event available, this method blocks for up to the optionally specified <code>timeout</code> time interval for an event to arrive. An empty time interval for <code>timeout</code> (the default) indicates that the method should not timeout (the method will not return until the next event is available). Return a <code><a class="el" href="classbmqa_1_1SessionEvent.html">bmqa::SessionEvent</a></code> of type <code><a class="el" href="structbmqt_1_1SessionEventType.html#aef449af38af76209352bf82f78b92529a1a1a1dc0cc1210cfef1574a0afe59339" title="Time out of the operation.">bmqt::SessionEventType::e_TIMEOUT</a></code> if a timeout was specified and that timeout expired before any event was received. Note that this method can only be used if the session is in synchronous mode (ie not using the EventHandler). The behavior is undefined unless the session was started. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#ab791e98ffb989c97411966856a4d527b">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a6e1d0349415ed25dafc141ad6d68c7e7"></a><!-- doxytag: member="bmqa::Session::post" ref="a6e1d0349415ed25dafc141ad6d68c7e7" args="(const MessageEvent &amp;event) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::Session::post </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1MessageEvent.html">MessageEvent</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously post the specified <code>event</code> that must contain one or more <code>Messages</code>. The return value is one of the values defined in the <code><a class="el" href="structbmqt_1_1PostResult.html#a61bdfd3cd65c26eaccf02390c514cd76" title="GENERIC.">bmqt::PostResult::Enum</a></code> enum. Return zero on success and a non-zero value otherwise. Note that success implies that SDK has accepted the <code>event</code> and will eventually deliver it to the broker. The behavior is undefined unless the session was started. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a5b338c949ef2d008e2e491bcc74f9ecd">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a0b977f8da81201169727727c8bc86c7c"></a><!-- doxytag: member="bmqa::Session::confirmMessage" ref="a0b977f8da81201169727727c8bc86c7c" args="(const Message &amp;message) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::Session::confirmMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1Message.html">Message</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>message</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously confirm the receipt of the specified <code>message</code>. This indicates that the application is done processing the message and that the broker can safely discard it from the queue according to the retention policy set up for that queue. Return 0 on success, and a non-zero value otherwise. Note that success implies that SDK has accepted the <code>message</code> and will eventually send confirmation notification to the broker. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#ac0fbce3bb5f93d991063bea9ea3ebb8d">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a165f5b7d76359fb497e57577fe672cec"></a><!-- doxytag: member="bmqa::Session::confirmMessage" ref="a165f5b7d76359fb497e57577fe672cec" args="(const MessageConfirmationCookie &amp;cookie) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::Session::confirmMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbmqa_1_1MessageConfirmationCookie.html">MessageConfirmationCookie</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cookie</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously confirm the receipt of the message with which the specified <code>cookie</code> is associated. This indicates that the application is done processing the message and that the broker can safely discard it from the queue according to the retention policy set up for that queue. Return 0 on success, and a non-zero value otherwise. Note that success implies that SDK has accepted the <code>message</code> and will eventually send confirmation notification to the broker. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#af78c7080723764b041baf5825fab4ed7">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="ad956f64b183e04e20c23ad7b8846eb28"></a><!-- doxytag: member="bmqa::Session::confirmMessages" ref="ad956f64b183e04e20c23ad7b8846eb28" args="(ConfirmEventBuilder *builder) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::Session::confirmMessages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbmqa_1_1ConfirmEventBuilder.html">ConfirmEventBuilder</a> *&nbsp;</td>
          <td class="paramname"> <em>builder</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously confirm the receipt of the batch of CONFIRM messages contained in the specified <code>builder</code>. This indicates that the application is done processing all of the messages and that the broker can safely discard them from the queue according to the retention policy set up for that queue. The return value is one of the values defined in the <code><a class="el" href="structbmqt_1_1GenericResult.html#a637624d4e7f6e21b9411b630769286cc">bmqt::GenericResult::Enum</a></code> enum. Note that in case of success, the instance pointed by the <code>builder</code> will be reset. Also note that success implies that SDK has accepted all of the messages in <code>builder</code> and will eventually send confirmation notification to the broker, whereas failure implies that none of the messages in <code>builder</code> were accepted. Behavior is undefined unless <code>builder</code> is non-null. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a8487ac7a95e51c25c6bbacf822786972">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a0600029292f5b33d5b22f9a7afab5c72"></a><!-- doxytag: member="bmqa::Session::configureMessageDumping" ref="a0600029292f5b33d5b22f9a7afab5c72" args="(const bslstl::StringRef &amp;command) BSLS_KEYWORD_OVERRIDE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bmqa::Session::configureMessageDumping </td>
          <td>(</td>
          <td class="paramtype">const bslstl::StringRef &amp;&nbsp;</td>
          <td class="paramname"> <em>command</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configure this session instance to dump messages to the installed logger at <code>ball::Severity::INFO</code> level according to the specified <code>command</code> that should adhere to the following pattern: </p>
<div class="fragment"><pre class="fragment">           IN|OUT|PUSH|ACK|PUT|CONFIRM ON|OFF|100|10s
</pre></div><p> where each token has a specific meaning: </p>
<ul>
<li>
<b>IN</b> : incoming (<code>PUSH</code> and <code>ACK</code>) events  </li>
<li>
<b>OUT</b> : outgoing (<code>PUT</code> and <code>CONFIRM</code>) events  </li>
<li>
<b>PUSH</b> : incoming <code>PUSH</code> events  </li>
<li>
<b>ACK</b> : incoming <code>ACK</code> events  </li>
<li>
<b>PUT</b> : outgoing <code>PUT</code> events  </li>
<li>
<b>CONFIRM</b> : outgoing <code>CONFIRM</code> events  </li>
<li>
<b>ON</b> : turn on message dumping until explicitly turned off  </li>
<li>
<b>OFF</b> : turn off message dumping  </li>
<li>
<b>100</b> : turn on message dumping for the next 100 messages  </li>
<li>
<b>10s</b> : turn on message dumping for the next 10 seconds  </li>
</ul>
<p>Above, the numerical values <code>100</code> and <code>10</code> are just for illustration purposes, and application can choose an appropriate positive numeric value for them. Also, pattern is case-insensitive. Return zero if <code>command</code> is valid and message dumping has been configured, non-zero value otherwise. The behavior is undefined unless the session has been started. </p>

<p>Reimplemented from <a class="el" href="classbmqa_1_1AbstractSession.html#a777888d11903cac52eb14915ad29e4be">bmqa::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a73f8ee8692ee8f1dac28889ab7c7484f"></a><!-- doxytag: member="bmqa::Session::impl" ref="a73f8ee8692ee8f1dac28889ab7c7484f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* bmqa::Session::impl </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Do <em>NOT</em> use. Internal function, reserved for BlazingMQ internal usage. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bmqa__session_8h_source.html">bmqa_session.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Jun 15 2023 11:58:51 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
